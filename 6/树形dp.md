## 树形 DP 与换根 DP 讲义

本讲义旨在系统性地介绍算法竞赛中重要的一个分支——**树形动态规划 (Tree DP)**，以及其拓展技巧——**换根动态规划 (Rerooting DP)**。我们将从树的基本概念出发，循序渐进，最终通过一系列经典例题，帮助读者深入理解并掌握相关知识。

### 一、 基础知识：树

在深入学习树形 DP 之前，我们首先需要对“树”这一数据结构有扎实的理解。

#### 1.1 树的定义与重要概念

*   **树 (Tree)**：是一种由 n (n>0) 个有限节点组成一个具有层次关系的集合。它有且仅有一个特定的称为**根 (Root)** 的节点，其余节点可以划分为 m (m>0) 个互不相交的有限集，其中每一个集合本身又是一棵树，并称为根的**子树 (Subtree)**。
*   **无向树 (Undirected Tree)**：边没有方向的树。在图论中，一个无向连通且无环的图就是一棵树。
*   **有向树 (Directed Tree)**：边有方向的树，通常方向是从父节点指向子节点。
*   **根 (Root)**：树中唯一一个没有父节点的节点。
*   **父节点 (Parent)** 与 **子节点 (Child)**：如果存在一条从节点 u 到节点 v 的有向边，那么 u 是 v 的父节点，v 是 u 的子节点。
*   **叶节点 (Leaf)**：没有子节点的节点。
*   **深度 (Depth/dep)**：通常指从根节点到某节点路径上的边数。根节点的深度为 0。
*   **子树大小 (Subtree Size/sz)**：以某节点为根的子树中包含的节点总数（包括其自身）。

#### 1.2 树的存储方式

为了在计算机中表示树，我们通常采用以下两种方式：

*   **`vector` (邻接表)**：使用 `vector<int> adj[N]` 来存储树，`adj[u]` 存储与节点 `u` 相邻的所有节点。这是 C++ 中非常常用且灵活的方式。
*   **链式前向星**：一种静态链表实现的邻接表，对于边数特别巨大的稀疏图，可能在空间和效率上略有优势。

**`vector` 存图模板 (C++)**
```cpp
#include <iostream>
#include <vector>

const int N = 100005;
vector<int> adj[N];

void add_edge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u); // 无向树
}
```

#### 1.3 深度优先搜索 (DFS) 与 DFS 序

*   **深度优先搜索 (DFS)**：是遍历树或图的一种基本算法。它从根节点开始，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。

**DFS 模板 (C++)**
```cpp
bool visited[N];

void dfs(int u, int parent) {
    visited[u] = true;
    // --- 在访问节点 u 时进行操作 ---

    for (int v : adj[u]) {
        if (v == parent) continue; // 防止在无向图中立即返回父节点
        dfs(v, u);
        // --- 在子节点 v 递归返回后进行操作 ---
    }
}
```

*   **DFS 序 (DFS Order)**：在对树进行深度优先遍历时，按照访问节点的顺序将节点排列起来，形成的序列就是 DFS 序。一个重要的性质是，任意一个节点的子树，在 DFS 序中都对应着连续的一段。 这个性质在解决某些子树查询问题时非常有用。

### 二、 树形动态规划 (Tree DP)

树形 DP 是一种在树形结构上进行动态规划的算法思想。 由于树的递归性质，树形 DP 通常也采用递归（DFS）的方式来实现。

**核心思想**：
1.  **定义状态**：`dp[u][state]` 通常表示以节点 `u` 为根的子树，在某种 `state` 下的最优值。
2.  **递归与转移**：通过 DFS 遍历树，先递归处理所有子节点，然后利用子节点已经计算出的 DP 值来更新当前节点的 DP 值。这个过程通常在 DFS 的回溯阶段完成，即“自底向上”的更新。
3.  **最终答案**：通常根节点的 DP 值就是问题的最终解。

---

### 三、 经典例题解析

#### 3.1 树上最大独立集（例题：没有上司的舞会）

**问题描述**：给定一棵树，每个节点有一个权值（快乐指数）。要求选出一些节点，使得任意两个被选中的节点之间没有边直接相连，并且选出的节点权值之和最大。

**分析**：这是一个典型的树形 DP 问题。对于每个节点 `u`，我们有两种选择：
1.  选择节点 `u` (参加舞会)。
2.  不选择节点 `u` (不参加舞会)。

**状态定义**：
*   `dp[u][1]`：表示以 `u` 为根的子树中，选择节点 `u` 时能获得的最大快乐指数。
*   `dp[u][0]`：表示以 `u` 为根的"子树"中，不选择节点 `u` 时能获得的最大快乐指数。

**状态转移方程**：
*   如果选择 `u` (`dp[u][1]`)，那么它的所有子节点 `v` 都不能被选择。
    `dp[u][1] = happiness[u] + Σ dp[v][0]` (对于所有子节点 `v`)
*   如果不选择 `u` (`dp[u][0]`)，那么它的每个子节点 `v` 既可以被选择，也可以不被选择。为了总和最大，我们应该取两者中的较大值。
    `dp[u][0] = Σ max(dp[v][0], dp[v][1])` (对于所有子节点 `v`)

**实现**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int N = 6005;
std::vector<int> adj[N];
int happiness[N];
long long dp[N][2];
bool has_father[N];

void dfs(int u) {
    dp[u][1] = happiness[u];
    dp[u][0] = 0;


    for (int v : adj[u]) {
    
	    if (v != fa[u])...
	    fa[v] = u;
        dfs(v);
        dp[u][1] += dp[v][0];
        dp[u][0] += max(dp[v][0], dp[v][1]);
    }
}

int main() {
    int n;
    std::cin >> n;
    for (int i = 1; i <= n; ++i) {
        std::cin >> happiness[i];
    }
    for (int i = 0; i < n - 1; ++i) {
        int l, k;
        std::cin >> l >> k;
        adj[k].push_back(l);
        adj[l].push_back(k);
        has_father[l] = true;
    }

    int root = 1;
    while (has_father[root]) {
        root++;
    }

    dfs(root);

    std::cout << std::max(dp[root][0], dp[root][1]) << std::endl;

    return 0;
}
```

#### 3.2 树上背包

**问题描述**：给定一棵带点权的树和一个容量为 `m` 的背包。选择一些节点放入背包，要求如果选择一个节点，则必须选择它的父节点（根节点除外）。每个节点的代价是1，价值是其权值。求最大总价值。

**分析**：这是背包问题和树形 DP 的结合。每个节点的子树可以看作一个物品组，我们需要在这些物品组中进行选择。

**状态定义**：
*   `dp[u][j]`：表示在以 `u` 为根的子树中，选择 `j` 个节点（包括 `u` 自身）所能获得的最大价值。

**状态转移方程**：
对于节点 `u` 和它的一个子节点 `v`，我们将子树 `v` 的信息合并到 `u` 上。这类似于一个分组背包的过程：
`dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k])`
其中 `j` 是分配给以 `u` 为根的子树（到目前为止）的总容量，`k` 是分配给子树 `v` 的容量。为了防止重复计算，枚举 `j` 时需要倒序。

```cpp
dp [n][V];
void dfs(u)
{
	dp[u][0] = 0;
	dp[u][1] = a[u];
	sz[u] = 1
	
	for (v : e[u]) // 
	{
		dfs(v)
		sz[u] += sz[v];
		for (int i = min(sz[u], m); i >= 0; --i)
			for (int j = sz[v]; j >= 0; --j) // vol = j val = dp[v][j]
				dp[u][i] = max(dp[u][i], dp[u][i - j] + dp[v][j]);
	}
	// O(n^2)
}
```


**实现**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int N = 105;
const int M = 105;
std::vector<int> adj[N];
int value[N];
long long dp[N][M];
int n, m;

void dfs(int u, int parent) {
    // 节点u必须选，所以占用一个容量，获得value[u]的价值
    dp[u][1] = value[u];

    for (int v : adj[u]) {
        if (v == parent) continue;
        dfs(v, u);
        // 倒序枚举容量，进行背包合并
        for (int j = m + 1; j >= 1; --j) {
            for (int k = 1; k < j; ++k) {
                if (dp[u][j - k] != -1) { // 保证j-k的状态是可达的
                    dp[u][j] = std::max(dp[u][j], dp[u][j - k] + dp[v][k]);
                }
            }
        }
    }
}

// 主函数需要初始化dp数组为-1（或一个极小值），并处理输入输出
```

### 四、 换根动态规划 (Rerooting DP)

换根 DP，又称二次扫描法，是树形 DP 的一种进阶技巧。 它适用于解决那些答案与指定哪个节点为根有关，且需要对每个节点都求解一次的问题。如果对每个节点都跑一遍树形 DP，复杂度会是 O(N^2)，而换根 DP 可以将其优化到 O(N)。

**核心思想**：
1.  **第一次扫描 (DFS)**：任意指定一个根（例如节点1），进行一次自底向上的树形 DP，计算出每个子树对它父亲的贡献。例如，计算以 `u` 为根的子树的相关信息（如子树大小、向下的最长链等）。
2.  **第二次扫描 (DFS)**：从第一次指定的根开始，进行一次自顶向下的 DP。在这次遍历中，我们计算每个节点从其父节点方向传来的贡献，并结合第一次扫描得到的子树内部信息，得到以当前节点为根时的最终答案。

---

### 五、 换根 DP 例题解析

#### 5.1 树的直径

**问题描述**：树上任意两节点之间最长的简单路径即为树的“直径”。求树的直径的长度。

**普通树形 DP 解法**：
对于任意一个节点 `u`，经过它的最长链长度等于从它出发向下的最长链长度 `d1[u]` 加上次长链长度 `d2[u]`。树的直径就是所有节点 `u` 的 `d1[u] + d2[u]` 的最大值。
*   `d1[u]`：以 `u` 为根的子树中，从 `u` 向下到叶节点的最长距离。
*   `d2[u]`：以 `u` 为根的子树中，从 `u` 向下到叶节点的次长距离（且路径不与最长路径共享第一条边）。
*   **状态转移**: `d1[u] = max(d1[u], d1[v] + edge_weight)`。 `d2[u]` 类似。

**换根 DP 解法**：
换根 DP 也可以用来求解树的直径。
1.  **第一次 DFS**：计算每个节点向下的最长链 `d1[u]`、次长链 `d2[u]` 和它们分别经过哪个子节点 `s1[u], s2[u]`。
2.  **第二次 DFS**：计算每个节点向上的最长链 `up[u]`。
    *   `up[v]` 表示从 `v` 的父节点 `u` 出发，不经过 `v` 方向所能到达的最远距离。
    *   这个距离可能是 `u` 的 `up[u]`，也可能是 `u` 的某条向下的链。
    *   如果 `v` 恰好是 `u` 向下最长链 `d1[u]` 上的后继节点，那么 `up[v] = edge_weight + max(up[u], d2[u])`。
    *   否则，`up[v] = edge_weight + max(up[u], d1[u])`。
3.  **统计答案**：对于每个节点 `i`，以它为根时，全局的最长路径就是 `max(d1[i], up[i])`。树的直径就是所有 `i` 的 `max(d1[i], up[i])` 的最小值所对应的那个点的 `d1[i]+up[i]`。（这个说法略有偏差，更准确的说法是，每个点的最长路径是 `d1[i]`, 直径是`max(d1[i]+d2[i])`和`max(d1[i]+up[i])`)。

#### 5.2 树的中心

**问题描述**：找到一个点，使得该点到树中其他所有点的最远距离最小。这个点就是树的中心。
找到一个点，删掉这个点和所连的所有边之后，剩下的所有联通块的。。。。。重心

**分析**：这个问题完美契合换根 DP 的应用场景。我们需要求出每个点作为根时，它到其他所有点的最远距离，然后取这些最远距离中的最小值。

```cpp
dfs(u, up_dis)
{
	int dis = 0;
	for (v : edge)
	{
		max(dis[v]...)
		if (dis[v] == d1)
			dfs(v, max(up_dis + 1, d2 + 1))
		else
			dfs(v, max(up_dis + 1, d1 + 1))
		
		
	}
	dis = max(dis, up_dis);
}
```

**状态定义与转移**：
这与用换根 DP 求树的直径非常相似。
1.  **第一次 DFS (`dfs1`)**: 从任意根（如1）出发，计算每个节点 `u` **向下**的最长距离 `d1[u]` 和次长距离 `d2[u]`，以及最长距离经过的子节点 `s1[u]`。
2.  **第二次 DFS (`dfs2`)**: 从根（如1）出发，计算每个节点 `u` **向上**的最长距离 `up[u]`。
    *   `up[j]` (j是u的子节点) 的计算依赖于 `up[u]` 和 `u` 的向下路径。
    *   如果 `j` 是 `u` 向下最长路径的来源 (即 `s1[u] == j`)，则 `u` 往上的路径不能再经过 `j`，所以 `up[j]` 的更新要依赖于 `u` 的次长向下路径 `d2[u]` 和向上路径 `up[u]`。 `up[j] = w[i] + max(up[u], d2[u])`。
    *   否则，`up[j]` 的更新依赖于 `u` 的最长向下路径 `d1[u]`。 `up[j] = w[i] + max(up[u], d1[u])`。
3.  **计算结果**：对每个节点 `i`，它到其他所有点的最远距离就是 `max(d1[i], up[i])`。我们只需要遍历所有节点，找出这个值的最小值即可。

**实现 (核心部分)**:
```cpp
// d1[u]: u向下的最长路, d2[u]: u向下的次长路
// s1[u]: u向下最长路经过的子节点
// up[u]: u向上的最长路
int d1[N], d2[N], s1[N], up[N]; 

void dfs1(int u, int father) {
    // ... 计算 d1[u], d2[u], s1[u] ...
    // 遍历u的子节点v
    //   dfs1(v, u);
    //   int distance = d1[v] + w(u,v);
    //   if (distance > d1[u]) { d2[u]=d1[u]; d1[u]=distance; s1[u]=v; }
    //   else if (distance > d2[u]) { d2[u]=distance; }
}

void dfs2(int u, int father) {
    // 遍历u的子节点v
    //   if (s1[u] == v) {
    //      up[v] = w(u,v) + max(up[u], d2[u]);
    //   } else {
    //      up[v] = w(u,v) + max(up[u], d1[u]);
    //   }
    //   dfs2(v, u);
}

int main() {
    // ... 建图 ...
    dfs1(1, -1);
    dfs2(1, -1);

    int min_dist = INF;
    for (int i = 1; i <= n; ++i) {
        min_dist = min(min_dist, max(d1[i], up[i]));
    }
    // ... 输出 min_dist ...
}
```