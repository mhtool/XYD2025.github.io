# 🧠 算法竞赛常用搜索策略讲义  
## 一、DFS（深度优先搜索）

### ✅ 适用场景：
- 搜索空间较小
- 需要枚举所有可能路径
- 可配合剪枝优化

### 📌 特点：
- 内存占用小
- 不保证最优解
- 易实现递归

```cpp
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

bool vis[N][M];

void dfs(int x, int y) {
    if (x == tx && y == ty) {
        // 找到目标
        return;
    }
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (!vis[nx][ny] && in_bounds(nx, ny)) {
            vis[nx][ny] = 1;
            dfs(nx, ny);
        }
    }
}
```

---

## 二、BFS（广度优先搜索）

### ✅ 适用场景：
- 最短路径问题（边权相等）
- 层次遍历
- 状态转移图明确

### 📌 特点：
- 找最短路径
- 内存占用大
- 使用队列结构

```cpp
struct Node {
    int x, y, d;
};

int bfs() {
    queue<Node> q;
    vector<vector<int>> vis(n, vector<int>(m));
    q.push({0, 0, 0});
    vis[0][0] = 1;

    while (!q.empty()) {
        auto [x, y, d] = q.front(); q.pop();
        if (x == n - 1 && y == m - 1) return d;
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !grid[nx][ny] && !vis[nx][ny]) {
                vis[nx][ny] = 1;
                q.push({nx, ny, d + 1});
            }
        }
    }
    return -1;
}
```

---

## 三、剪枝技巧（Pruning）

### ✅ 常用剪枝类型：

| 类型 | 描述 |
|------|------|
| 可行性剪枝 | 提前判断当前状态不可能达到目标 |
| 最优性剪枝 | 当前路径代价已超过记录的最优值 |
| 记忆化剪枝 | 保存已访问状态避免重复计算 |
| 顺序剪枝 | 调整扩展顺序，优先尝试更优分支 |

### 📌 示例（可行性剪枝）：

```cpp
void dfs(int u, int sum) {
    if (sum > target) return; // 可行性剪枝
    if (u == n) {
        if (sum == target) ans++;
        return;
    }
    dfs(u + 1, sum + a[u]);
    dfs(u + 1, sum);
}
```

---

## 四、IDDFS（Iterative Deepening DFS）  
### —— 迭代加深搜索

### ✅ 适用场景：
- 搜索树深且未知
- 需找最浅解（类似 BFS）
- 内存受限时替代 BFS

### 📌 特点：
- 每次限制最大深度进行 DFS
- 若未找到解，则增加深度继续搜
- 内存小，适合大规模状态空间

```cpp
int max_depth;

bool dfs(int x, int y, int depth) {
    if (depth > max_depth) return false;
    if (x == tx && y == ty) return true;
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (in_bounds(nx, ny) && !vis[nx][ny]) {
            vis[nx][ny] = 1;
            if (dfs(nx, ny, depth + 1)) return true;
            vis[nx][ny] = 0;
        }
    }
    return false;
}

int iddfs() {
    for (max_depth = 0; ; max_depth++) {
        memset(vis, 0, sizeof vis);
        if (dfs(sx, sy, 0)) return max_depth;
    }
}
```

---


## 五、A*（启发式搜索）

### ✅ 适用场景：
- 大规模状态空间
- 需找最小代价路径
- 有良好启发函数可用

### 📌 特点：
- 启发函数 `h(x)` 估计当前状态到目标的代价
- 优先队列维护节点，按 `f = g + h` 排序
- 保证最优解当 `h ≤ h*`（不高于真实代价）

![[Pasted image 20250712133521.png]]
![[Pasted image 20250712133528.png]]
```cpp
struct Node {
    int x, y, g, h;
    bool operator<(const Node &o) const {
        return g + h > o.g + o.h;
    }
};

priority_queue<Node> pq;
int h(int x, int y)
{
	return abs(tx - x) + abs(ty - y);
}
int astar() {
    pq.push({sx, sy, 0, heuristic(sx, sy)});
    while (!pq.empty()) {
        auto now = pq.top(); pq.pop();
        if (now.x == tx && now.y == ty) return now.g;
        for (int i = 0; i < 4; ++i) {
            int nx = now.x + dx[i], ny = now.y + dy[i];
            if (in_bounds(nx, ny) && !grid[nx][ny]) {
                int ng = now.g + 1;
                int nh = h(nx, ny);
                pq.push({nx, ny, ng, nh});
            }
        }
    }
    return -1;
}
```

---

## 六、IDA*（迭代加深 A*）

### ✅ 适用场景：
- 内存受限
- 搜索树深
- 需找最优解

### 📌 特点：
- 结合 DFS 与 A* 启发
- 每次设定最大允许的 `f = g + h`
- 若超限则剪枝
- 不用优先队列，节省内存

```cpp
int max_depth;

int heuristic(int x, int y) {
    return abs(x - tx) + abs(y - ty); // 曼哈顿距离
}

bool dfs(int x, int y, int g) {
    int f = g + heuristic(x, y);
    if (f > max_depth) return false;
    if (x == tx && y == ty) return true;
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (in_bounds(nx, ny) && !grid[nx][ny]) {
            if (dfs(nx, ny, g + 1)) return true;
        }
    }
    return false;
}

int ida_star() {
    max_depth = heuristic(sx, sy);
    while (true) {
        if (dfs(sx, sy, 0)) return max_depth;
        max_depth++; // 增加深度限制
    }
}
```

---

## 七、总结对比表

| 方法     | 是否最优 | 内存友好 | 适合大规模 | 是否需启发 | 重复搜索 |
|----------|-----------|-------------|------------------|----------------|--------------|
| DFS      | ❌         | ✅           | ❌                 | ❌               | ❌            |
| BFS      | ✅         | ❌           | ✅（小范围）       | ❌               | ❌            |
| IDDFS    | ✅         | ✅           | ✅                 | ❌               | ✅            |
| A*       | ✅         | ❌           | ✅（有好启发）     | ✅               | ❌            |
| IDA*     | ✅         | ✅           | ✅                 | ✅               | ✅            |

---

## 八、选择建议

| 场景 | 推荐方法 |
|------|-----------|
| 小规模暴力 | DFS/BFS |
| 内存有限 + 最优解 | IDA* / IDDFS |
| 大规模 + 有启发函数 | A* |
| 需找最浅解 | IDDFS |
| 需高效剪枝 | IDA* |

---

## 九、示例：走迷宫问题统一接口

假设地图为 `n × m` 的二维数组，起点 `(0, 0)`，终点 `(n-1, m-1)`，0 表示可走，1 表示障碍。

你只需替换调用函数即可测试不同算法：

```cpp
int main() {
    // 输入地图 grid[n][m]
    
    // 测试不同算法：
    cout << "DFS: " << dfs(0, 0) << endl;
    cout << "BFS: " << bfs() << endl;
    cout << "IDDFS: " << iddfs() << endl;
    cout << "A*: " << astar() << endl;
    cout << "IDA*: " << ida_star() << endl;

    return 0;
}
```

---
