
### 1. 什么是状态？它和 DFS 参数有什么关系？

在学习动态规划之前，我们通常会先接触深度优先搜索 (DFS)。在 DFS 中，我们通过函数的参数来描述当前搜索到了哪一步，以及这一步的局面是怎样的。例如，在走迷宫问题中，`dfs(x, y)` 的参数 `x` 和 `y` 就描述了当前在地图中的位置。

**动态规划中的“状态”，本质上就是对问题特定阶段的描述，与 DFS 函数的参数异曲同工。** 一个状态对应着一个或多个子问题，以及这些子问题的解。

举个例子，在爬楼梯问题中，我们要爬到第 `n` 阶楼梯。我们可以定义一个状态 `dp[i]`，表示爬到第 `i` 阶楼梯的方案数。这里的 `i` 就相当于我们 DFS 函数 `dfs(i)` 中的参数 `i`，都描述了“当前在第几阶楼梯”这个局面。

**关键区别在于：**

*   **DFS (朴素递归)**：可能会反复进入相同的状态 (即用相同的参数调用函数)，导致大量的重复计算。
*   **DP**：通过记录每个状态的解，避免重复计算。当再次遇到同一个状态时，直接使用已经算好的结果。

所以，你可以这样理解：**DP 就是“聪明的”DFS**。它通过“记忆”来避免了普通 DFS 的重复劳动。

### 2. 数字三角形模型：理解状态转移

我们来看一个最经典的 DP 入门问题——数字三角形，来深入理解状态和状态转移。

**问题描述：**

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其下方的结点或移动至其右下方的结点，一直走到底层。要求找出一条路径，使路径上的数字的和最大。

**样例输入：**
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**样例输出：**
```
30
```

---

#### 状态定义

我们来定义一个状态。根据前面的讲解，状态就是对问题某个阶段的描述。在这个问题中，我们关心的是从某个点出发能得到的最大和。因此，我们可以定义 `dp[i][j]` 为：**从第 `i` 行第 `j` 个数字出发，走到最底层所能得到的最大路径和**。

*   `i` 代表行号 (从1开始)
*   `j` 代表列号 (从1开始)

#### 状态转移方程

“状态转移”听起来很高级，但其实就是思考：**当前状态的解，可以从哪些后续状态推导出来？**

对于 `dp[i][j]`，我们站在第 `i` 行第 `j` 个数的位置，下一步只能走到左下方 (`i+1`, `j`) 或者右下方 (`i+1`, `j+1`)。为了让从 `(i, j)` 出发的路径和最大，我们肯定会选择一个能让后续路径和更大的走法。

所以，我们可以得到状态转移方程：
`dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1])`

其中 `a[i][j]` 是数字三角形在 `(i, j)` 位置的数值。

**这个方程是什么意思呢？**
从 `(i, j)` 点出发到最底层的最大和，等于当前点 `a[i][j]` 的值，加上“从左下角 `(i+1, j)` 出发到最底层的最大和”与“从右下角 `(i+1, j+1)` 出发到最底层的最大和”这两者中较大的一个。

**边界条件：**
当 `i` 在最后一行 (第 `n` 行) 时，已经没有地方可以走了。所以，`dp[n][j] = a[n][j]`。

最终我们要求解的就是从 `(1, 1)` 点出发的最大路径和，即 `dp[1][1]`。

#### 从后往前递推

根据状态转移方程，我们发现，想要求 `dp[i][j]`，需要先知道 `dp[i+1]` 层的结果。所以，一个很自然的计算顺序是从最后一行开始，逐层向上递推，直到第一行。

**C++ 实现 (递推)：**

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int MAXN = 105;
int a[MAXN][MAXN];
int dp[MAXN][MAXN];

int main() {
    int n;
    cin >> n;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            cin >> a[i][j];
        }
    }

    // 初始化边界条件：最后一行
    for (int j = 1; j <= n; ++j) {
        dp[n][j] = a[n][j];
    }

    // 从倒数第二行开始向上递推
    for (int i = n - 1; i >= 1; --i) {
        for (int j = 1; j <= i; ++j) {
            dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]);
        }
    }

    cout << dp[1][1] << endl;

    return 0;
}
```

#### 运算符的改变

神奇的是，同样的状态转移逻辑，我们只需要改变运算符，就能解决不同种类的问题：
*   **求最大值 (本例)**：`dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]);`
*   **求最小值**：`dp[i][j] = a[i][j] + min(dp[i+1][j], dp[i+1][j+1]);`
*   **求方案数**：假设我们想知道从 `(i,j)` 走到最底层的路径有多少条。
    `count[i][j] = count[i+1][j] + count[i+1][j+1];`
    (边界条件 `count[n][j] = 1`)

### 3. 记忆化搜索与 DP 的关系

我们再回头看数字三角形问题。除了从后往前递推，我们也可以很自然地写出一个从前往后的递归（DFS）解法。

**朴素 DFS (自顶向下)：**

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 105;
int a[MAXN][MAXN];
int n;

int dfs(int i, int j) {
    // 递归边界
    if (i == n) {
        return a[i][j];
    }

    // 递归求解子问题
    int left_sum = dfs(i + 1, j);
    int right_sum = dfs(i + 1, j + 1);

    return a[i][j] + max(left_sum, right_sum);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            cin >> a[i][j];
        }
    }
    cout << dfs(1, 1) << endl;
    return 0;
}
```

这个 DFS 会超时，因为它会重复计算很多相同的 `dfs(i, j)`。例如，`dfs(3, 2)` 既会被 `dfs(2, 1)` 调用，也会被 `dfs(2, 2)` 调用。

**记忆化搜索 (Memoization)** 就是给这个 DFS 加上一个“备忘录”，记录下每个状态 `(i, j)` 的计算结果，避免重复计算。

**C++ 实现 (记忆化搜索)：**

```cpp
#include <iostream>
#include <algorithm>
#include <cstring> // 用于 memset

using namespace std;

const int MAXN = 105;
int a[MAXN][MAXN];
int memo[MAXN][MAXN]; // 备忘录
int n;

int dfs(int i, int j) {
    // 如果已经计算过，直接返回结果
    if (memo[i][j] != -1) {
        return memo[i][j];
    }

    // 递归边界
    if (i == n) {
        return memo[i][j] = a[i][j];
    }

    // 递归求解子问题
    int left_sum = dfs(i + 1, j);
    int right_sum = dfs(i + 1, j + 1);

    // 存入备忘录并返回
    return memo[i][j] = a[i][j] + max(left_sum, right_sum);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            cin >> a[i][j];
        }
    }

    // 初始化备忘录为-1，表示都未计算过
    memset(memo, -1, sizeof(memo));

    cout << dfs(1, 1) << endl;
    return 0;
}
```

**关系总结：**

*   **记忆化搜索**：是**自顶向下**的递归形式，从目标状态开始求解，遇到子问题再递归下去。
*   **DP (递推)**：是**自底向上**的迭代形式，从边界状态开始，一步步推导出目标状态的解。
*   **本质**：两者在本质上是等价的，都是通过解决重叠子问题来求解原问题。 记忆化搜索可以看作是 DP 的一种实现方式。

### 4. DAG 上的 DP 与记忆化搜索的应用

很多动态规划问题，都可以抽象成在一个**有向无环图 (DAG)** 上寻找最长路、最短路或路径计数的问题。

*   **点 (Vertex)**：代表 DP 中的“状态”。
*   **有向边 (Directed Edge)**：代表状态之间的“转移”。
*   **无环 (Acyclic)**：保证了状态转移不会形成循环，这是 DP 问题能被解决的前提（即无后效性）。

数字三角形问题，就可以看作一个 DAG：每个数字是一个节点，每个节点向它的左下方和右下方节点连一条有向边。我们求的最大路径和，本质上就是这个 DAG 上的最长路径。

**什么时候记忆化搜索更好用？**

当状态转移的顺序不那么规则，不方便用 `for` 循环来迭代时，记忆化搜索的形式往往更简洁、更直观。

**例子：最长递增路径**

**问题描述：**
给定一个 `m x n` 的整数矩阵，找出其中最长递增路径的长度。对于每个单元格，你可以往上、下、左、右四个方向移动。你不能在对角线方向上移动或移动到边界外。

**样例输入：**
```
3 3
9 9 4
6 6 8
2 1 1
```
**样例输出：**
```
4
```
(路径是 1 -> 2 -> 6 -> 9)

这个问题就很难用一个简单的 `for` 循环来确定计算顺序，因为一个点的最长递增路径依赖于它周围比它大的点，而这些点的位置是不固定的。

但用记忆化搜索就非常自然：

1.  **状态定义**：`dp[i][j]` 表示从 `(i, j)` 出发的最长递增路径长度。
2.  **状态转移**：`dp[i][j] = 1 + max(dp[x][y])`，其中 `(x, y)` 是 `(i, j)` 四周中数值大于 `a[i][j]` 的点。如果没有这样的点，`dp[i][j] = 1`。
3.  **最终答案**：所有 `dp[i][j]` 中的最大值。

**C++ 实现 (记忆化搜索)：**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int m, n;
vector<vector<int>> matrix;
vector<vector<int>> memo;

// 方向数组
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int dfs(int r, int c) {
    if (memo[r][c] != 0) {
        return memo[r][c];
    }

    int max_len = 1;
    for (int i = 0; i < 4; ++i) {
        int nr = r + dx[i];
        int nc = c + dy[i];

        if (nr >= 0 && nr < m && nc >= 0 && nc < n && matrix[nr][nc] > matrix[r][c]) {
            max_len = max(max_len, 1 + dfs(nr, nc));
        }
    }

    return memo[r][c] = max_len;
}

int main() {
    cin >> m >> n;
    matrix.assign(m, vector<int>(n));
    memo.assign(m, vector<int>(n, 0));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> matrix[i][j];
        }
    }

    int ans = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            ans = max(ans, dfs(i, j));
        }
    }

    cout << ans << endl;

    return 0;
}
```

### 总结

希望这份讲义能帮助你对动态规划有一个初步的认识。请记住以下核心要点：

*   **状态** 是对子问题的描述，与 DFS 的参数类似。
*   **状态转移方程** 是连接不同状态之间解的桥梁。
*   **记忆化搜索** (自顶向下) 和 **递推** (自底向上) 是实现 DP 的两种主要方式，本质相通。
*   许多 DP 问题可以被看作 **DAG** 上的路径问题。
*   当状态转移不规则时，**记忆化搜索**是你的好朋友。

动态规划的世界博大精深，这只是一个开始。不断练习，你会发现它的强大与优美。祝你在算法学习的道路上越走越远！