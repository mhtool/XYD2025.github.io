好的，我们来探讨经典的 0-1 背包问题的两种核心解法：记忆化搜索（自顶向下）和动态规划（自底向上）。我们将分别讨论“存在性”问题和“最大值”问题。

### 0-1 背包问题描述

假设有 `N` 件物品和一个容量为 `V` 的背包。第 `i` 件物品的体积（或重量）是 `c[i]`，价值是 `w[i]`。每件物品只能选择放一次（0-1选择）。

*   **存在性问题**：能否恰好装满容量为 `V` 的背包？（这里我们只关心体积，不考虑价值）
*   **最大值问题**：在不超过背包总容量的前提下，能获得的最大总价值是多少？

---

### 1. 存在性问题 (恰好装满)

#### (1) 记忆化搜索 (自顶向下)

**思路：**

我们定义一个递归函数 `dfs(i, j)`，表示**从前 `i` 个物品中选择，能否恰好凑成容量 `j`**。这是一个布尔类型的问题。

在 `dfs(i, j)` 中，我们考虑第 `i` 个物品：

*   **不选第 `i` 个物品**：问题转化为，能否从前 `i-1` 个物品中凑成容量 `j`，即 `dfs(i-1, j)`。
*   **选第 `i` 个物品**：前提是 `j >= c[i]`。问题转化为，能否从前 `i-1` 个物品中凑成容量 `j - c[i]`，即 `dfs(i-1, j - c[i])`。

只要这两种情况有一种能成功，`dfs(i, j)` 就返回 `true`。

递归的边界是：
*   如果 `j == 0`，说明容量已经凑满，成功，返回 `true`。
*   如果 `i == 0` 且 `j > 0`，说明没有物品可选了但容量还没凑满，失败，返回 `false`。

**C++ 代码：**

```cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

int n, V;
int c[1005];       // 物品体积
int memo[1005][1005]; // 备忘录，-1:未计算, 0:false, 1:true

/**
 * @brief 从前 i 个物品中选择，能否恰好凑成容量 j
 * @param i 当前考虑第 i 个物品 (从 1 到 n)
 * @param j 剩余需要凑成的容量
 * @return true 如果可以凑成, false 如果不可以
 */
bool dfs(int i, int j) {
    // 递归边界：容量刚好凑满
    if (j == 0) {
        return true;
    }
    // 递归边界：没有物品可选了 或 容量为负
    if (i <= 0 || j < 0) {
        return false;
    }

    // 如果已经计算过，直接返回结果
    if (memo[i][j] != -1) {
        return memo[i][j];
    }

    // 状态转移
    // 1. 不选第 i 个物品
    bool res = dfs(i - 1, j);

    // 2. 选第 i 个物品 (前提是放得下)
    if (j >= c[i]) {
        res = res || dfs(i - 1, j - c[i]);
    }
    
    // 存入备忘录并返回
    return memo[i][j] = res;
}

int main() {
    cout << "请输入物品数量 N 和背包容量 V: ";
    cin >> n >> V;
    cout << "请输入 " << n << " 个物品的体积: ";
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
    }

    // 初始化备忘录为 -1
    memset(memo, -1, sizeof(memo));

    if (dfs(n, V)) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }

    return 0;
}
```

#### (2) 动态规划 (自底向上)

**思路：**

我们定义一个二维数组 `dp[i][j]`，其含义与记忆化搜索中的状态定义完全相同：**表示从前 `i` 个物品中选择，能否恰好凑成容量 `j`**。

状态转移方程也完全一样，只是我们用循环的方式来计算：
`dp[i][j] = dp[i-1][j] || dp[i-1][j - c[i]]`

*   `dp[i-1][j]`：不选第 `i` 个物品的情况。
*   `dp[i-1][j - c[i]]`：选第 `i` 个物品的情况 (当 `j >= c[i]` 时)。

边界条件是 `dp[0][0] = true`，表示“从前0个物品里凑成容量0”是可行的。其他 `dp[0][j]` 均为 `false`。

**C++ 代码：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    cout << "请输入物品数量 N 和背包容量 V: ";
    int n, V;
    cin >> n >> V;

    vector<int> c(n + 1);
    cout << "请输入 " << n << " 个物品的体积: ";
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
    }

    // dp[i][j]: 从前 i 个物品中选，能否恰好凑成容量 j
	// V <= 1000
	int dp;
	bitset<1005> dp;
	// dp.set(0);
	dp[0] = 1;
	
    // 状态转移
    for (int i = 1; i <= n; ++i) {
		dp |= dp << c[i];
    }

    if (dp >> V & 1) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }

    return 0;
}
```

---

### 2. 最大值问题

#### (1) 记忆化搜索 (自顶向下)

**思路：**

定义递归函数 `dfs(i, j)`，表示**从前 `i` 个物品中选择，在背包容量限制为 `j` 的情况下，能获得的最大价值**。

在 `dfs(i, j)` 中，我们考虑第 `i` 个物品：

*   **不选第 `i` 个物品**：能获得的最大价值等于从前 `i-1` 个物品中选择，容量限制仍为 `j` 的最大价值，即 `dfs(i-1, j)`。
*   **选第 `i` 个物品**：前提是 `j >= c[i]`。能获得的最大价值等于第 `i` 个物品的价值 `w[i]` 加上 “从前 `i-1` 个物品中选择，容量限制为 `j - c[i]` 的最大价值”，即 `w[i] + dfs(i-1, j - c[i])`。

`dfs(i, j)` 的结果就是这两种情况中的较大值。

递归边界是：当 `i <= 0` 或 `j <= 0` 时，没有物品可选或没有容量，最大价值为 0。

**C++ 代码：**

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

int n, V;
int c[1005], w[1005]; // 体积和价值
int memo[1005][1005]; // 备忘录

/**
 * @brief 从前 i 个物品中选择，容量限制为 j 的最大价值
 * @param i 当前考虑第 i 个物品 (从 1 到 n)
 * @param j 剩余可用容量
 * @return 最大价值
 */
int dfs(int i, int j) {
    // 递归边界：没有物品可选或没有容量了
    if (i <= 0 || j <= 0) {
        return 0;
    }

    // 如果已经计算过，直接返回结果
    if (memo[i][j] != -1) {
        return memo[i][j];
    }

    // 状态转移
    // 1. 不选第 i 个物品
    int res = dfs(i - 1, j);

    // 2. 选第 i 个物品 (前提是放得下)
    if (j >= c[i]) {
        res = max(res, w[i] + dfs(i - 1, j - c[i]));
    }
    
    // 存入备忘录并返回
    return memo[i][j] = res;
}

int main() {
    cout << "请输入物品数量 N 和背包容量 V: ";
    cin >> n >> V;
    cout << "请输入 " << n << " 个物品的体积和价值: " << endl;
    for (int i = 1; i <= n; ++i) {
        cin >> c[i] >> w[i];
    }

    // 初始化备忘录为 -1
    memset(memo, -1, sizeof(memo));

    cout << "最大价值是: " << dfs(n, V) << endl;

    return 0;
}
```

#### (2) 动态规划 (自底向上)

**思路：**

定义 `dp[i][j]` 为**从前 `i` 件物品中选择，放入一个容量为 `j` 的背包可以获得的最大价值**。

状态转移方程：
`dp[i][j] = max(dp[i-1][j], dp[i-1][j - c[i]] + w[i])`

*   `dp[i-1][j]`：不选第 `i` 个物品的情况，价值不变。
*   `dp[i-1][j - c[i]] + w[i]`：选择第 `i` 个物品的情况（当 `j >= c[i]` 时）。

边界条件：`dp[0][j]` 和 `dp[i][0]` 均为 0，因为没有物品或没有容量时，最大价值为0。

**C++ 代码（二维数组）：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    cout << "请输入物品数量 N 和背包容量 V: ";
    int n, V;
    cin >> n >> V;

    vector<int> c(n + 1), w(n + 1);
    cout << "请输入 " << n << " 个物品的体积和价值: " << endl;
    for (int i = 1; i <= n; ++i) {
        cin >> c[i] >> w[i];
    }

    // dp[i][j]: 从前 i 个物品中选，放入容量为 j 的背包的最大价值
    vector<vector<int>> dp(n + 1, vector<int>(V + 1, 0));

    // 状态转移
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= V; ++j) {
            // 1. 不选第 i 个物品
            dp[i][j] = dp[i-1][j];
            // 2. 选第 i 个物品 (前提是放得下)
            if (j >= c[i]) {
                dp[i][j] = max(dp[i][j], dp[i-1][j - c[i]] + w[i]);
            }
        }
    }

    cout << "最大价值是: " << dp[n][V] << endl;

    return 0;
}
```

*注意：0-1背包的DP解法可以优化到一维空间，这里为了和记忆化搜索进行清晰的对比，使用了二维数组。*

---

### 对比与总结

| 特性 | 记忆化搜索 (Memoization) | 动态规划 (DP) |
| :--- | :--- | :--- |
| **思维方式** | **自顶向下 (Top-Down)**，从目标问题 `dfs(n, V)` 开始，递归分解成子问题。 | **自底向上 (Bottom-Up)**，从边界状态 `dp[0][0]` 开始，迭代计算，逐步构建出目标解 `dp[n][V]`。 |
| **实现方式** | **递归 + 备忘录 (数组)**。代码结构和朴素递归很像，易于思考和实现。 | **循环 (通常是多重循环)**。需要明确地规划计算顺序。 |
| **计算范围** | **只计算需要的状态**。如果某些子问题在求解目标问题的过程中从未被涉及到，那么它们就不会被计算。 | **计算所有可能的状态**。`for` 循环会填满整个 `dp` 数组（或至少是大部分），不管某些状态是否对最终答案有贡献。 |
| **代码直观性** | **更直观**。状态转移的逻辑直接体现在递归调用中，接近人类的自然思考方式。 | **相对不直观**。需要设计好循环的顺序和边界，但逻辑清晰，没有函数调用开销。 |
| **性能** | 有递归函数调用的开销，但通常可以忽略不计。在状态空间稀疏时可能更快，因为它只计算用到的状态。 | 没有递归开销，循环迭代通常更快。在状态空间稠密时表现稳定。 |
| **本质** | 两者都是动态规划思想的体现，都是通过解决重叠子问题和利用最优子结构来求解问题。记忆化搜索可以看作是“懒加载”的动态规划。 |  |

**核心 takeaway：**

*   **记忆化搜索是“推”式的**：我需要什么(`dfs(i,j)`)，我就去计算什么。
*   **动态规划是“拉”式的**：我根据已知状态(`dp[i-1]`)，去更新未知状态(`dp[i]`)。

对于初学者来说，从朴素的 DFS 暴力解法开始思考，然后加上一个 `memo` 数组来“记忆化”，是转变为 DP 思维的一条平滑路径。当问题状态转移关系复杂，不方便用 `for` 循环表示时，记忆化搜索是更优的选择。而对于像 0-1 背包这类状态转移非常规律的问题，自底向上的 DP 写法效率更高，也更常用。



```cpp
for(int i=1;i<=n;i++)
	for(int k=1;k<=cnt[i];++k)
		for(int j=m;j>=v[i];j--)
			f[j]=max(f[j],f[j-v[i]]+w[i]);
```
