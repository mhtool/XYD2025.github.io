### 一、最短路问题概述

#### 1. 什么是图？
一个图由**顶点（Vertex）**和**边（Edge）**组成。边连接着顶点，并且可以带有一个**权重（Weight）**，通常表示两个顶点之间的距离、成本或时间。

#### 2. 什么是最短路？
给定一个图，一个源点 `s` 和一个终点 `t`，最短路问题就是找到一条从 `s` 到 `t` 的路径，使得这条路径上所有边的权重之和最小。

#### 3. 问题的分类
*   **单源最短路（Single-Source Shortest Path, SSSP）**：计算从一个固定的源点 `s` 到图中所有其他顶点的最短路。
*   **全源最短路（All-Pairs Shortest Path, APSP）**：计算图中每一对顶点 `(u, v)` 之间的最短路。

#### 4. 边的权重
*   **正权图**：所有边的权重都是正数。
*   **含负权边**：图中存在权重为负数的边。
*   **负权环**：图中存在一个环，环上所有边的权重之和为负数。如果存在负权环，从环上任意一点出发绕一圈回到该点，路径长度会减少。这意味着最短路可能没有定义（可以无限地绕圈刷低路径长度）。

接下来，我们将针对不同的场景，学习三大核心算法：Floyd-Warshall, Bellman-Ford, 和 Dijkstra。

---

### 二、Floyd-Warshall 算法（全源最短路）

Floyd算法用于解决全源最短路问题。它非常直观，基于动态规划的思想。

#### 1. 核心原理：动态规划
Floyd的核心思想是“**允许经过的中间点**”的不断放宽。

我们定义一个状态 `dist[k][i][j]`，它表示**只允许使用编号从 1 到 k 的顶点作为中间点**时，从顶点 `i` 到顶点 `j` 的最短路径长度。

为了求解 `dist[k][i][j]`，我们有两种选择：

1.  **不经过**顶点 `k`：那么从 `i` 到 `j` 的最短路径，就等同于只允许经过 `1` 到 `k-1` 作为中间点时的最短路。其长度为 `dist[k-1][i][j]`。
2.  **经过**顶点 `k`：那么路径一定是从 `i` 先到 `k`，再从 `k` 到 `j`。这两段路程都只允许使用 `1` 到 `k-1` 作为中间点。其长度为 `dist[k-1][i][k] + dist[k-1][k][j]`。

综合这两种情况，我们就得到了状态转移方程：
$dist[k][i][j] = \min(dist[k-1][i][j], \quad dist[k-1][i][k] + dist[k-1][k][j])$

在实现时，我们可以发现 `k` 这一维可以被压缩掉，因为计算第 `k` 轮时只依赖于第 `k-1` 轮的结果。这使得我们可以直接在二维数组 `dist[i][j]` 上进行更新。

最终的状态转移方程简化为：
`dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`

**关键点**：`k` 必须是**最外层**的循环。因为当我们用 `k` 来更新 `dist[i][j]` 时，必须保证 `dist[i][k]` 和 `dist[k][j]` 已经是只经过 `1` 到 `k-1` 中间点时的最优解。只有将 `k` 放在最外层，才能保证在处理 `k` 时，所有比 `k` 小的中间点都已经被考虑过了。

#### 2. 算法特性
*   **适用场景**：全源最短路，顶点数量较少（通常 $N \le 400$）。
*   **复杂度**：时间复杂度 $O(N^3)$，空间复杂度 $O(N^2)$。
*   **负权边**：可以正确处理负权边。
*   **负权环**：可以判断负权环。如果在算法结束后，存在 `dist[i][i] < 0`，说明从 `i` 出发可以经过一个负权环再回到 `i`，从而使得路径长度为负。

#### 3. C++ 模板代码
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;
const int MAXN = 405;

int dist[MAXN][MAXN];
int n, m; // n: 顶点数, m: 边数

bitset<MAXN> f[MAXN];

vector<int> edge[MAXN];

void floyd_warshall() {
    // k必须是第一层循环
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
			if (f[i][k])
				f[i] |= f[k];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m;

    // 1. 初始化邻接矩阵
    for (int i = 1; i <= n; ++i) {
		 f[i][j] = 1;
    }

    // 2. 读入边
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        // 处理重边，保留最短的
		f[u][v] = 1;
    }

    // 3. 运行Floyd-Warshall
    floyd_warshall();

    // 4. (可选) 检测负权环
    for (int i = 1; i <= n; ++i) {
        if (dist[i][i] < 0) {
            cout << "Graph contains a negative cycle." << endl;
            return 0;
        }
    }

    // 输出结果 (示例)
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (dist[i][j] == INF) {
                cout << "INF ";
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << endl;
    }

    return 0;
}
```

---

### 三、Bellman-Ford 算法（单源最短路）

Bellman-Ford算法用于解决单源最短路问题，它最大的特点是能够处理负权边，并能检测出从源点可达的负权环。

#### 1. 核心原理：松弛操作
Bellman-Ford的原理是反复对图中的所有边进行**松弛（Relaxation）**操作。

**松弛操作**：对于一条边 `(u, v)`，其权重为 `w`。如果当前从源点 `s` 到 `v` 的距离 `dist[v]` 大于 从 `s` 到 `u` 的距离 `dist[u]` 加上边 `(u, v)` 的权重 `w`，即 `dist[v] > dist[u] + w`，我们就找到了一个经过 `u` 到达 `v` 的更短的路径。此时，我们更新 `dist[v] = dist[u] + w`。

**算法流程**：
1.  初始化源点 `s` 的距离 `dist[s] = 0`，其他所有点的距离 `dist` 为无穷大。
2.  对图中**所有**的 `m` 条边，进行 `n-1` 轮松弛操作。

**为什么是 n-1 轮？**
因为在一个不包含负权环的图中，任意两点间的最短路最多包含 `n-1` 条边。
*   经过第 1 轮松弛，我们能保证找到所有从源点出发、最多经过 1 条边的最短路。
*   经过第 2 轮松弛，我们能保证找到所有从源点出发、最多经过 2 条边的最短路。
*   ...
*   以此类推，经过 `n-1` 轮松弛，我们就能保证找到所有从源点出发、最多经过 `n-1` 条边的最短路，这已经覆盖了所有可能的简单路径（无环路径）。

**负权环检测**：
如果在完成了 `n-1` 轮松弛之后，在第 `n` 轮松弛中，仍然有边的 `dist` 值可以被更新，这说明什么？这说明我们找到了一条包含 `n` 条边的路径，比之前包含少于 `n` 条边的路径还要短。在一个有 `n` 个顶点的图中，一条包含 `n` 条边的简单路径是不存在的，所以这必然意味着路径中出现了一个环，而且这个环是负权的，使得路径总长度进一步减小了。

#### 2. 算法特性
*   **适用场景**：单源最短路，图中含有负权边。
*   **复杂度**：时间复杂度 $O(N \cdot M)$。
*   **负权边**：可以正确处理。
*   **负权环**：主要用途之一就是检测负权环。

#### 3. C++ 模板代码
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;
const int MAXN = 505;

struct Edge {
    int from, to, weight;
};

int dist[MAXN];
vector<Edge> edges;
int n, m; // n: 顶点数, m: 边数

bool bellman_ford(int start_node) {
    // 1. 初始化
    for (int i = 1; i <= n; ++i) {
        dist[i] = INF;
    }
    dist[start_node] = 0;

    // 2. n-1 轮松弛
    // n-1 轮 已经更新完了
	// 差分约束系统
	// O(n*m)
	// SPFA 尝试对 Bellman-Ford 优化
	// n，m 1e5 SPFA NOI 爆零 0
	// SPFA死了
	// SPFA 卡您
    for (int i = 1; i <= n; ++i) {
	    // u, v, w
        for (const auto& edge : edges) {
	        auto [u, v, w] = edge;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (i == n)
	            {
		            flag = 1;
	            }
            }
        }
    }

    // 3. 第 n 轮检查负权环
    for (const auto& edge : edges) {
        if (dist[edge.from] != INF && dist[edge.to] > dist[edge.from] + edge.weight) {
            return true; // 发现负权环
        }
    }

    return false; // 没有负权环
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u, v, w});
    }

    int start_node = 1;
    bool has_negative_cycle = bellman_ford(start_node);

    if (has_negative_cycle) {
        cout << "Graph contains a negative cycle reachable from source." << endl;
    } else {
        for (int i = 1; i <= n; ++i) {
            if (dist[i] == INF) {
                cout << "INF ";
            } else {
                cout << dist[i] << " ";
            }
        }
        cout << endl;
    }


	O(n*m)
	
	queue<int> q;
	inque[N]
	cnt[N];
	q.push(S);
	while (!q.empty())
	{
		int u = q.front();
		inque[u] = false;
		for (auto [v, w] : edge[u])
		{
			if (dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				if (!inque[v])
				{
					++cnt[v];
					if (cnt[v] >= n)
						flag = true;
					inque[v] = true;
					q.push(v);
				}
			}
		}
	}
}
```
*注：SPFA算法是Bellman-Ford的一种队列优化版本，在大多数情况下比Bellman-Ford快，但最坏情况下复杂度相同，并且可能被特殊构造的数据卡到最坏情况。*

---

### 四、Dijkstra 算法（单源最短路）

Dijkstra算法是解决**无负权边**图上单源最短路问题的最常用、最高效的算法。

#### 1. 核心原理：贪心
Dijkstra是一种贪心算法。它的核心思想是：

1.  将顶点分为两个集合：`S`（已确定最短路径的顶点）和 `U`（未确定最短路径的顶点）。
2.  初始时，`S` 中只有源点 `s`，`U` 中包含其他所有顶点。`dist[s] = 0`，其他 `dist` 为无穷。
3.  循环执行以下操作，直到 `U` 为空：
    a. 从 `U` 中选择一个 `dist` 值最小的顶点 `u`。
    b. 将 `u` 从 `U` 移到 `S`。
    c. 对所有从 `u` 出发的边 `(u, v)`，进行松弛操作：`dist[v] = min(dist[v], dist[u] + w(u,v))`。

**贪心选择的正确性证明（核心）**：
为什么每次选择当前 `dist` 最小的顶点 `u`，就可以断定 `dist[u]` 已经是最终的最短路径了呢？

我们可以用反证法证明。假设当我们选择 `dist` 最小的顶点 `u` 时，它的这个 `dist[u]` 值并不是真正的最短路。那么，一定存在另一条从源点 `s` 到 `u` 的更短的路径 `P`。

这条路径 `P` 一定是 `s -> ... -> x -> y -> ... -> u` 的形式，其中 `x` 是路径 `P` 上第一个在 `S` 集合中的点，而 `y` 是紧随其后的第一个在 `U` 集合中的点。（`x`可能是`s`自己）

因为我们假设了**所有边的权重都是非负的**，所以从 `s` 到 `y` 的路径长度 `dist_P(s, y)` 必定小于等于 `s` 到 `u` 的路径长度 `dist_P(s, u)`。

又因为 `x` 点在 `S` 中，`dist[x]` 已经是最终的最短路。路径 `s -> ... -> x -> y` 的长度为 `dist[x] + w(x,y)`。松弛操作保证了 `dist[y] <= dist[x] + w(x,y) = dist_P(s, y)`。

综合起来，我们有：`dist[y] <= dist_P(s, y) <= dist_P(s, u)`。

我们最初的假设是 `dist_P(s, u)` 是比 `dist[u]` 更短的路径，即 `dist_P(s, u) < dist[u]`。
所以我们推导出 `dist[y] < dist[u]`。

但这与我们的算法步骤矛盾了！`y` 也在 `U` 集合中，并且 `dist[y] < dist[u]`，那我们当时应该选择 `y` 而不是 `u`。所以假设不成立。

因此，Dijkstra算法的贪心选择是正确的。**这个证明的关键在于 `w >= 0`**。如果存在负权边，`dist_P(s, y) <= dist_P(s, u)` 就不一定成立了，整个证明就崩溃了。

#### 2. 实现方式：优先队列优化
如果每次都从 `U` 中暴力扫描找 `dist` 最小的顶点，总时间复杂度是 $O(N^2)$。我们可以使用**优先队列（最小堆）**来优化这个查找过程。

1.  用一个优先队列存储 `pair<distance, vertex_id>`。
2.  每次从队首取出 `dist` 最小的顶点 `u`。
3.  对 `u` 的邻居 `v` 进行松弛。如果 `dist[v]` 被更新，就将新的 `(dist[v], v)` 放入优先队列。

#### 3. 算法特性
*   **适用场景**：单源最短路，**图中不能有负权边**。
*   **复杂度**：使用优先队列优化后，时间复杂度为 $O(M \log N)$。
*   **负权边**：**不能**处理。

#### 4. C++ 模板代码
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <utility> // for pair

using namespace std;

const int INF = 1e9;
const int MAXN = 100005;

typedef pair<int, int> pii; // <distance, vertex>

vector<pii> adj[MAXN]; // <neighbor, weight>
int dist[MAXN];
bool visited[MAXN];
int n, m;

void dijkstra(int start_node) {
    // 1. 初始化
    for (int i = 1; i <= n; ++i) {
        dist[i] = INF;
        visited[i] = false;
    }
    dist[start_node] = 0;

    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, start_node});

    while (!pq.empty()) {
        // 2. 贪心选择dist最小的未访问顶点
        int u = pq.top().second;
        pq.pop();

        // 如果已经访问过，则跳过。这是为了处理队列中旧的、更长的路径信息
        if (visited[u]) {
            continue;
        }
        visited[u] = true;

        // 3. 对u的所有邻居进行松弛
        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[v] > dist[u] + weight) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m;
    int start_node;
    cin >> start_node;

    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
        // 如果是无向图，加上 adj[v].push_back({u, w});
    }

    dijkstra(start_node);

    for (int i = 1; i <= n; ++i) {
        if (dist[i] == INF) {
            cout << "INF ";
        } else {
            cout << dist[i] << " ";
        }
    }
    cout << endl;


void dijkstra(int S)
{
	dis[S] = 0;
	vector<int> vis(n + 1);
	using pr = pair<ll, int>;
	priority_queue<pair<ll,int>> Q;
	Q.push({0, S});
	//小根堆
	while (!Q.empty()) 
	{
		auto [now, u] = Q.top();
		if (vis[u])
			continue;
		assert(-now == dis[u]);
		vis[u] = true;
		Q.pop();
		for (auto [v, w] : E[u])
			if (dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				Q.push({-dis[u], v});
			}
	}
}
T -> pre[T]
pre[T] -> ...


O(mlog(n))

n = 1e5 ~ 1e6;
m = 1e6;

dijkstra

d[i][j][k]
str 字符串
a 数组




```

### 五、总结

| 算法 | 问题类型 | 时间复杂度 | 能否处理负权边 | 能否处理负权环 |
| :--- | :--- | :--- | :---: | :---: |
| **Floyd-Warshall** | 全源最短路 | $O(N^3)$ | 能 | 能检测 |
| **Bellman-Ford** | 单源最短路 | $O(N \cdot M)$ | 能 | 能检测 |
| **Dijkstra** | 单源最短路 | $O(M \log N)$ | **不能** | **不能** |

选择哪个算法，取决于你的具体需求：图的规模、是否有负权边、是求单源还是全源。理解每个算法的原理，是灵活运用它们解决问题的关键。