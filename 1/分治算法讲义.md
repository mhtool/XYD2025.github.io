# 分治算法讲义

## 1. 分治算法概述

### 1.1 什么是分治算法
分治算法（Divide and Conquer）是一种重要的算法设计策略，它将一个复杂问题分解为几个规模较小的相同问题，分别求解这些子问题，然后将子问题的解合并得到原问题的解。

### 1.2 分治算法的基本思想
分治算法的基本思想可以概括为三个步骤：
1. **分解（Divide）**：将原问题分解为若干个规模较小的子问题
2. **解决（Conquer）**：递归地解决各个子问题，当子问题规模足够小时，直接求解
3. **合并（Combine）**：将各个子问题的解合并为原问题的解

### 1.3 分治算法的通用特征
- **问题的规模缩小到一定程度时可以容易地解决**
- **问题可以分解为若干个规模较小的相同问题**
- **子问题的解可以合并为原问题的解**
- **子问题是相互独立的**

### 1.4 分治算法的复杂度分析
分治算法的时间复杂度通常可以用递推关系来表示：
- $T(n) = aT(n/b) + f(n)$
- 其中 $a$ 是子问题的数量，$n/b$ 是子问题的规模，$f(n)$ 是分解和合并的时间复杂度

根据**主定理（Master Theorem）**，可以分析分治算法的复杂度：
- 如果 $f(n) < n^{\log_b a}$，则 $T(n) = n^{\log_b a}$
- 如果 $f(n) = n^{\log_b a}$，则 $T(n) = n^{\log_b a} \log n$
- 如果 $f(n) > n^{\log_b a}$，则 $T(n) = f(n)$


## 2. 经典例题

### 2.1 递归绘制图形 - 分形图案

**题目描述：**
给定一个正整数 $n$，绘制一个 $n$ 层的分形图案。第 1 层是一个字符 '\*'，第 $k$ 层是将第 $k-1$ 层的图案复制 4 份，分别放在左上、右上、左下、右下四个位置。

**输入格式：**
一个正整数 $n$ $(1 \leq n \leq 8)$

**输出格式：**
输出 $n$ 层分形图案

**样例输入：**
```
1
```

**样例输出：**
```
*
```

**样例输入：**
```
2
```

**样例输出：**
```
* *
 *
* *
```

**样例输入：**

```
3
```

**样例输出：**
```
* *   * *
 *     *
* *   * *
   * *
    *
   * *
* *   * *
 *     *
* *   * *
```

**解题思路：**
1. **递归基础**：当层数为 1 时，直接输出 '*'
2. **递归关系**：第 $k$ 层由 5 个第 $k-1$ 层组成
3. **合并策略**：将五个子图案按照特定位置组合

**时间复杂度**：$O(3^{2n})$，**空间复杂度**：$O(3^{2n})$

**代码实现：**

```cpp
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>

using namespace std;
const int N = 5005; // 3^7 = 2187

char graph[N][N];

void draw(int x, int y, int size)
{
    if (size == 1)
    {
        graph[x][y] = '*';
        return;
    }
    int half = size / 3;
    draw(x, y, half);                               // 左上
    draw(x, y + half * 2, half);                    // 右上
    draw(x + half, y + half, half);                 // 中间
    draw(x + half * 2, y, half);                    // 左下
    draw(x + half * 2, y + half * 2, half);         // 右下
}
int main() {
    int n;
    scanf("%d", &n);
    
    int size = 1;
    for (int i = 1; i < n; ++i)
        size *= 3;
    memset(graph, ' ', sizeof(graph));
    draw(0, 0, size);
    for (int i = 0; i < size; ++i)
    {
        for (int j = size - 1; j >= 0; --j)
        {
            if (graph[i][j] == ' ')
                graph[i][j] = '\0';
            else if (graph[i][j] == '*')
                break;
        }
    }
    for (int i = 0; i < size; ++i)
    {
        for (int j = 0; j < size && graph[i][j]; ++j)
            printf("%c", graph[i][j]);
        printf("\n");   
    }
}
```

### 2.2 最大连续和

**题目描述：**
给定一个整数数组，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**输入格式：**
第一行包含一个整数 $n$ $(1 \leq n \leq 10^5)$
第二行包含 $n$ 个整数，表示数组元素 $(-10^9 \leq a_i \leq 10^9)$

**输出格式：**
输出最大子序列和

```cpp
int now = 0, mx = -1e9;
for (int i = 1; i <= n; ++i)
{
	now += a[i];
	
	if (now > mx)
		mx = now;
	if (now < 0)
		now = 0
}
```
**样例输入：**
```
9
-2 1 -3 4 -1 2 1 -5 4
```

**样例输出：**
```
6
```

**解题思路：**
1. **分解**：将数组分为左右两部分
2. **递归求解**：分别求出左半部分和右半部分的最大子序列和
3. **合并**：考虑跨越中点的最大子序列和，取三者最大值

**时间复杂度**：$O(n \log n)$，**空间复杂度**：$O(\log n)$

**代码实现：**

```cpp
#include <cstdio>
using namespace std;

typedef long long ll;

const int N = 1e5 + 5;

int a[N];
array<ll, 3> solve(int l, int r)
{
    int mid = (l + r) / 2;
    if (l == r)
        return {a[l], a[r], a[mid]};
    auto lres = solve(l, mid);
    auto rres = solve(mid + 1, r);
    ll res = max(max(lres[2], rres[2]), lres[1] + rres[0]);
    ll now = 0, lmx = -1e18, rmx = -1e18;
    for (int i = l; i <= r; ++i)
        now += a[i], lmx = max(lmx, now);
    now = 0;
    for (int i = r; i >= l; --i)
        now += a[i], rmx = max(rmx, now);
    return {lmx, rmx, res};
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    auto ans = solve(1, n)
    printf("%lld\n", ans[2]); 
}
```

### 2.3 归并排序

**题目描述：**
给定一个长度为 $n$ 的整数数组，请使用归并排序算法将其按升序排列。

**输入格式：**
第一行包含一个整数 $n$ $(1 \leq n \leq 10^5)$
第二行包含 $n$ 个整数 $a_i$ $(-10^9 \leq a_i \leq 10^9)$

**输出格式：**
输出排序后的数组

**样例输入：**
```
6
3 1 4 1 5 9
```

**样例输出：**
```
1 1 3 4 5 9
```

**解题思路：**
1. **分解**：将数组分为两个子数组
2. **递归求解**：对两个子数组分别排序
3. **合并**：将两个已排序的子数组合并为一个有序数组

**时间复杂度**：$O(n \log n)$，**空间复杂度**：$O(n)$

**代码实现：**

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 1e5 + 5;

int a[N], tmp[N];

void merge_sort(int l, int r)
{
    if (l == r)
        return;
    int mid = (l + r) / 2;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    for (int i = l; i <= r; ++i)
        tmp[i] = a[i];
    int i = l, j = mid + 1, k = i;
    while (i <= mid || j <= r)
        if (j > r || a[i] <= a[j])
            a[k++] = a[i];
        else
            a[k++] = a[i];
}

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    merge_sort(1, n);
    for (int i = 1; i <= n; ++i)
        cout << a[i] << " ";
    cout << endl;
}
```

### 2.4 平面最近点对

**题目描述：**
在平面上给定 $n$ 个点，求出其中距离最近的两个点的距离。

**输入格式：**
第一行包含一个整数 $n$ $(2 \leq n \leq 10^5)$
接下来 $n$ 行，每行包含两个整数 $x_i, y_i$，表示第 $i$ 个点的坐标 $(-10^4 \leq x_i, y_i \leq 10^4)$

**输出格式：**
输出最近点对的距离，保留 6 位小数

**样例输入：**
```
4
0 0
1 1
2 2
3 0
```

**样例输出：**
```
1.414214
```

**解题思路：**
1. **预处理**：按 $x$ 坐标排序
2. **分解**：将点集分为左右两部分
3. **递归求解**：分别求出左右两部分的最近点对距离
4. **合并**：考虑跨越分界线的最近点对，取最小值

**时间复杂度**：$O(n \log n)$，**空间复杂度**：$O(n)$

**代码实现：**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin >> n;
    using Point = pair<double, double>;
    vector<Point> points;
    for (int i = 0; i < n; ++i)
    {
        double x, y;
        cin >> x >> y;
        points.emplace_back(x, y);
    }
    sort(points.begin(), points.end());
    auto dis = [](Point a, Point b)
    {
        auto pow = [](double x, double y)
        { return x * x + y * y; };
        return pow(a.first - b.first, a.second - b.second);
    };
    auto closest = [&](auto &&self, auto l, auto r) -> double
    {
        if (r - l == 1)
            return LONG_LONG_MAX;
        auto mid = l + (r - l) / 2;
        double midX = mid->first;
        double d = min(self(self, l, mid), self(self, mid, r));
        double sqrtD = sqrt(d);
        inplace_merge(l, mid, r, [](Point a, Point b)
                      { return a.second < b.second; });
        vector<decltype(l)> mids;
        for (auto it = l; it != r; ++it)
            if (abs(it->first - midX) < sqrtD)
                mids.push_back(it);

		for (int i = 0; i < len; ++i)
            for (int j = i + 1; dis(i, j) < sqrtD && j < len; ++j)
	                d = min(d, dis(**it, **jt));
        return d;
    };
    printf("%.6f\n", 2 * sqrt(closest(closest, points.begin(), points.end())) / 2);
}
```

### 2.5 快速幂（分治的经典应用）

**题目描述：**
计算 $a^n \bmod m$ 的值，其中 $a, n, m$ 都是正整数。

**输入格式：**
一行三个整数 $a, n, m$ $(1 \leq a, n, m \leq 10^9)$

**输出格式：**
输出 $a^n \bmod m$ 的值

**解题思路：**
利用分治思想，将指数分解：
$$a^n = \begin{cases}
(a^{n/2})^2 & \text{if } n \text{ is even} \\
a \cdot (a^{n/2})^2 & \text{if } n \text{ is odd}
\end{cases}$$

**时间复杂度**：$O(\log n)$，**空间复杂度**：$O(\log n)$

**代码实现：**

```cpp
#include <cstdio>
using namespace std;

typedef long long ll;

ll Qpow(int a, int n, int mod)
{
    if (n == 1)
        return a;
    int res = Qpow(a, n / 2, mod);
    if (n % 2 == 1)
        return 1ll * res * res % mod * a % mod;
    return 1ll * res * res % mod;
}
```

## 3. 分治算法的应用总结

### 3.1 适用场景
1. **问题具有递归结构**：可以分解为相同类型的子问题
2. **子问题相互独立**：子问题之间没有重叠
3. **合并操作效率高**：能够高效地合并子问题的解

### 3.2 常见分治算法模板

```cpp
// 分治算法通用模板
ResultType divide_and_conquer(Problem problem) {
    // 递归基：问题规模足够小时直接求解
    if (problem.size <= THRESHOLD) {
        return solve_directly(problem);
    }
    
    // 分解：将问题分解为子问题

	solve(l, mid)
	solve(mid + 1, r)
    
    // 递归求解子问题
    vector<ResultType> subresults;
    for (const auto& subproblem : subproblems) {
        subresults.push_back(divide_and_conquer(subproblem));
    }
    
    // 合并：组合子问题的解
    return combine(subresults);
}
```

### 3.3 复杂度分析要点
- **递归关系**：建立正确的递归关系式
- **主定理**：使用主定理快速分析复杂度
- **空间复杂度**：考虑递归调用栈的空间开销
- **实际性能**：考虑常数因子和实际运行环境

### 3.4 优化技巧
1. **阈值优化**：小规模问题使用更简单的算法
2. **尾递归优化**：避免过深的递归调用
3. **内存优化**：减少临时空间的使用
4. **并行化**：利用子问题的独立性进行并行计算

分治算法是算法设计中的重要工具，通过合理地分解问题、递归求解和合并结果，可以有效地解决许多复杂问题。掌握分治思想对于算法学习和竞赛编程都具有重要意义。 