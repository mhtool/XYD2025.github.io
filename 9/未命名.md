Tarjan 算法是一种在图论中用于寻找有向图的强连通分量的经典算法。理解 `low` 数组的定义和其与 `dfn` 数组的协同工作方式，是掌握该算法的关键。

### Tarjan 算法的核心概念

在 Tarjan 算法中，我们对图进行深度优先搜索 (DFS)，并在此过程中维护两个核心数组：`dfn` 和 `low`，以及一个栈。

*   **`dfn` (Depth First Number) 数组**：也称为时间戳，`dfn[u]` 记录了节点 `u` 在深度优先搜索中被访问到的次序。 每个节点的时间戳都是唯一的，并且在整个 DFS 过程中不会改变。
*   **`low` 数组**：`low[u]` 记录了从节点 `u` (以及 `u` 在搜索树中的子树) 出发，能够通过非树边（回边或横叉边）到达的、并且仍在栈中的节点中，最小的 `dfn` 值。
*   **栈**：用于存储在深度优先搜索过程中已经访问过但尚未被划分到任何强连通分量的节点。

### `low` 数组的定义和更新

`low` 数组的精髓在于它帮助我们判断一个节点是否是一个强连通分量的“根”节点。

1.  **初始化**：当一个节点 `u` 第一次被访问时，它的 `dfn[u]` 和 `low[u]` 都会被设置为当前的访问次序号。 同时，节点 `u` 会被压入栈中。

2.  **更新规则**：在深度优先搜索的过程中，从节点 `u` 遍历到其邻接点 `v` 时，会有以下几种情况：
    *   **`v` 未被访问过**：这形成了一条树边。我们递归地对 `v` 进行深度优先搜索，即调用 `tarjan(v)`。当从 `v` 的搜索回溯到 `u` 时，我们更新 `low[u]`，令 `low[u] = min(low[u], low[v])`。这是因为如果 `v` 能到达一个更早的节点，那么 `u` 也能通过 `v` 到达那个节点。
    *   **`v` 已被访问过且仍在栈中**：这形成了一条回边或横叉边，指向一个仍在当前路径上的祖先节点。这意味着我们找到了一个环。此时，我们用 `v` 的 `dfn` 值来更新 `u` 的 `low` 值，即 `low[u] = min(low[u], dfn[v])`。
    *   **`v` 已被访问过但已不在栈中**：这说明 `v` 所在的强连通分量已经被确定，它与当前正在处理的节点无关，因此我们不做任何操作。

### 利用 `dfn` 和 `low` 判断强连通分量

Tarjan 算法正确性的核心在于以下判定条件：

**如果一个节点 `u` 的 `dfn[u]` 值与 `low[u]` 值相等，那么这个节点 `u` 就是一个强连通分量的根。**

**为什么这个判定是正确的？**

*   `dfn[u] == low[u]` 的情况意味着，从 `u` 和它的子树出发，无法通过回边或横叉边到达任何一个在 DFS 过程中比 `u` 更早被访问到的、并且仍在栈中的节点。
*   换句话说，`u` 是它所在的强连通分量中第一个被访问到的节点。
*   由于深度优先搜索的特性，所有在 `u` 之后被访问并且能通过路径回到 `u` 的节点，都会在 `u` 的搜索完成之前被处理。
*   当 `dfn[u] == low[u]` 成立时，栈中从 `u` 到栈顶的所有节点就构成了一个强连通分量。 这是因为这些节点都是在 `u` 的搜索过程中入栈的，并且它们都能通过某种路径回到 `u`（否则 `low` 值会被更新为更小的值），同时 `u` 无法到达更早的节点，保证了这个分量的极大性。

因此，当找到这样一个根节点 `u` 时，我们就可以不断地从栈中弹出节点，直到 `u` 被弹出为止。所有这些弹出的节点就共同构成了一个强连通分量。

### 总结

`low` 数组的巧妙定义和更新机制，使得 Tarjan 算法能够高效地识别出强连通分量的边界。通过比较 `dfn[u]` 和 `low[u]`，算法能够准确地找到每个强连通分量在深度优先搜索树中的“最高点”或“根”，从而将属于同一分量的节点一次性地从栈中取出，保证了算法的正确性和 O(N+M) 的线性时间复杂度，其中 N 是节点数，M 是边数。