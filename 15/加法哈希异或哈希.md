好的，这是一份为您精心制作的、包含从入门到进阶的全套内容的异或哈希讲义。讲义结构清晰，涵盖了您要求的所有题目，并为核心案例提供了详细的思路剖析和带有注释的完整代码。

---

## **异或哈希 (XOR Hashing) 讲义：从入门到解决复杂计数问题**

给你一个数组 a 2n - 1,  只有一个元素没有出现两次, 没有出现过的元素。 $n$
```cpp
int ans = 0;
for (int i = 1; i <= n; ++i)
{
	int x;
	cin >> x;
	ans ^= x;
}

cout << ans << endl;



```
### **第一部分：预备知识 — 哈希与异或**

#### **1.1 哈希 (Hashing) 的核心思想**

在计算机科学中，哈希是一种将任意大小的数据（例如一个字符串、一个对象）通过一个**哈希函数**映射到一个固定大小的值（**哈希值**）的方法。

一个优秀的哈希函数通常具备以下特点：
*   **确定性**：相同的输入永远得到相同的输出。
*   **高效性**：计算过程非常快。
*   **抗碰撞性**：很难找到两个不同的输入，它们会产生相同的哈希值。

#### **1.2 异或 (XOR) 运算的魔力**

异或 (在 C++ 等语言中用 `^` 表示) 是一种二进制位运算。它的神奇之处在于其独特的数学性质，这些性质是异或哈希算法的基石。

1.  **自反性**: $A \oplus A = 0$ (任何数与自身异或，结果为 0)
2.  **交换律**: $A \oplus B = B \oplus A$
3.  **结合律**: $(A \oplus B) \oplus C = A \oplus (B \oplus C)$
4.  **单位元**: $A \oplus 0 = A$ (任何数与 0 异或，结果不变)

**自反性 ($A \oplus A = 0$) 是异或哈希的灵魂**。这个“可撤销”的特性使它成为处理区间和状态变化问题的利器。

---

### **第二部分：核心案例分析**

我们将通过两个核心案例，从不同维度展示异或哈希的强大威力。

---

### **核心案例 1：统计“好的”子数组 (按k次出现)**

这个问题是异或哈希的经典应用，它完美地展示了如何将一个抽象的“计数状态”转化为可计算的哈希值。

#### **题目描述**
> YangQiShaoNian 有一个长度为 $n$ 的数组。数组中的一个子数组 $[l, r]$ 被称为“好的”，当且仅当在该区间内的每个元素 $a_l, a_{l+1}, \dots, a_r$ 恰好出现 $k$ 次。
>
> 请帮助 YangQiShaoNian 找出可以选出的“好的”区间的数量。

#### **输入输出样例**

**输入**
```
2
7 2
1 1 2 3 2 3 1
4 1
1 2 3 4
```

**输出**
```
6
6
```
*(在第一个样例中，对于 k=2，好的区间有,, 等)*

#### **思路解析**

1.  **问题转化**：直接枚举区间并统计的复杂度为 $O(N^2)$ 或更高，无法接受。我们需要一个 $O(N)$ 或 $O(N \log N)$ 的算法。利用**前缀和**思想，如果能将“区间内每个数恰好出现k次”这个性质，表示为 `状态[r] ^ 状态[l-1] == 某个特定值`，问题就迎刃而解。

2.  **状态哈希化**：
    *   我们为每个数字的**每一次出现**都赋予一个独特的、随机的哈希值。
    *   **关键设计**：我们希望一个数字出现 $k$ 次后，它对总哈希值的影响能被“清零”。
    *   当数字 $x$ 第 $j$ 次 ($1 \le j < k$) 出现时，生成一个随机哈希值 $H(x, j)$。同时，我们用一个变量 `total[x]` 记录下这些哈希值的异或和：`total[x] = H(x,1) ^ ... ^ H(x, k-1)`。
    *   当数字 $x$ 第 $k$ 次出现时，我们不再生成随机数，而是让它的哈希值 $H(x, k) = \text{total}[x]$。这样一来，前 $k$ 次出现的哈希总和为 $H(x,1) \oplus \dots \oplus H(x,k-1) \oplus H(x,k) = \text{total}[x] \oplus \text{total}[x] = 0$。
    *   当数字 $x$ 第 $j$ 次 ($j > k$) 出现时，我们让它的哈希值与第 $j-k$ 次出现时相同，即 $H(x, j) = H(x, j-k)$。这保证了哈希值以 $k$ 为周期循环，使得出现 $k, 2k, 3k, \dots$ 次的数字块，其内部的哈希和总是 0。

3.  **前缀异或和**：
    *   定义前缀哈希和 $S[i]$ 为位置 1 到 $i$ 所有元素对应哈希值的异或总和。
    *   如果一个区间 $[l, r]$ 内所有数字都出现了 $k$ 的倍数次，那么其哈希和 $S[r] \oplus S[l-1]$ 必定为 0。
    *   问题转化为：寻找所有满足 $S[r] \oplus S[l-1] = 0 \implies S[r] = S[l-1]$ 的下标对 $(l-1, r)$ 的数量。

4.  **“恰好k次”的约束**：
    *   上述方法只能保证出现次数是 $k$ 的倍数。题目要求**恰好** $k$ 次。
    *   这意味着，对于一个合法的区间 $[l, r]$，不能有任何数字出现 $2k, 3k, \dots$ 次。
    *   **解决方案**：当我们处理到右端点 $i$ 时，如果 $a[i]$ 是其第 `c > k` 次出现，那么任何有效的左端点 $l$ 必须位于 $a[i]$ 的第 `c-k` 次出现位置之后。否则区间内就会包含 $a[i]$ 的 $k+1$ 个实例。
    *   我们用一个指针 `now` 维护当前有效的最左边界。当 $a[i]$ 的出现次数超过 $k$ 时，就将 `now` 移动到 $a[i]$ 的第 `c-k` 次出现位置，并将在 `now` 左边的所有前缀和从我们的计数哈希表 `cnt` 中移除。

#### **代码实现与解读**

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <random>
#include <chrono>

// 为了代码简洁，使用 long long 作为 ll
using ll = long long;

// 使用高质量的随机数生成器
// mt19937_64 mrand(std::chrono::steady_clock::now().time_since_epoch().count());
// 为了复现性，使用一个固定的种子
mt19937_64 mrand(231654); 

// 生成一个64位的随机哈希值
unsigned long long RAND() {
    return mrand();
}

void solve() {
    int n;
    int k;
    std::cin >> n >> k;
    std::vector<int> a(n + 1);

    // 定义所需的类型和数据结构
    using ull = unsigned long long;
    
    // pos[{val, count}] = index，记录值为val的数第count次出现在哪个位置
    std::map<std::pair<int, int>, int> pos; 
    
    // num[val] = count，记录值val当前出现了几次
    std::map<int, int> num; 
    
    // total[val] 记录值val前k-1次出现的哈希值的异或和
    std::map<int, ull> total_hash_for_k;
    
    // hash_val[i] 存储a[i]这个元素实例对应的哈希值
    std::vector<ull> hash_val(n + 1);
    
    // numer[i] 记录a[i]是其数值的第几次出现
    std::vector<int> numer(n + 1);

    // 步骤1 & 2: 预处理，为每个元素实例计算其状态哈希值
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
        int current_val = a[i];
        
        // 更新当前值的出现次数
        numer[i] = ++num[current_val];
        int current_count = numer[i];

        // 记录当前元素实例的位置
        pos[{current_val, current_count}] = i;

        if (current_count > k) {
            // 周期性：第 c 次出现的哈希值等于第 c-k 次出现的哈希值
            hash_val[i] = hash_val[pos[{current_val, current_count - k}]];
        } else if (current_count == k) {
            // 第 k 次出现，哈希值等于前 k-1 次的异或和，使得k个一组的哈希和为0
            hash_val[i] = total_hash_for_k[current_val];
        } else {
            // 前 k-1 次出现，生成随机哈希值，并累加到total_hash_for_k中
            ull h = RAND();
            hash_val[i] = h;
            total_hash_for_k[current_val] ^= h;
        }
    }

    // 步骤 3 & 4: 计算前缀和并统计答案
    std::vector<ull> prefix_sum(n + 1, 0);
    ll ans = 0;
    
    // cnt[sum] = count，记录某个前缀和出现了多少次
    std::map<ull, int> cnt;
    
    // now 是滑动窗口的左边界，代表合法的 l-1 最早可以取到的位置
    int now = 0; 
    
    // S[0] = 0，空前缀的哈希和为0，出现1次
    cnt[0]++; 

    for (int i = 1; i <= n; ++i) {
        // 计算当前的前缀异或和
        prefix_sum[i] = prefix_sum[i - 1] ^ hash_val[i];

        // 维护滑动窗口，处理“恰好k次”的约束
        if (numer[i] > k) {
            // a[i]是其第c>k次出现，那么l-1必须在a[i]的第c-k次出现的位置p-1之后
            int p = pos[{a[i], numer[i] - k}];
            // 将所有不合法的左端点（的l-1）从cnt中移除
            while (now < p) {
                cnt[prefix_sum[now]]--;
                now++;
            }
        }
        
        // 累加答案：在当前合法的窗口内，有多少个 l-1 使得 S[l-1] == S[i]
        ans += cnt[prefix_sum[i]];
        
        // 将当前的 S[i] 加入计数
        cnt[prefix_sum[i]]++;
    }
    std::cout << ans << '\n';
}

int main() {
    // 提高cin/cout效率
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### **核心案例 2：寻找完美排列子数组**

这个问题展示了异或哈希的另一种用法：校验两个集合是否相等。它需要更灵活的思维和算法设计。
```cpp

map<int, ull> hash;

vector<ull> sum(n + 1);
vector<ull> psum(n + 1);
for (int i = 1; i <= n; ++i)
	hash[i] = rand(), psum[i] = psum[i - 1] ^ hash[i];

for (int i = 1; i <= n; ++i)
{
	cin >> a[i];
	sum[i] = sum[i - 1] ^ hash[a[i]];
}

map<ull, int> cnt;
++cnt[0];
int ans = 0;
for (int i = 1; i <= n; ++i)
{
	ull now = sum[i] ^ psum[i];
	ans += cnt[now];
	++cnt[now];
}



```
#### **题目描述**
> 给一个长度为 $n$ 的数组 $a$，找到所有的连续子序列 $[l, r]$，满足：该子序列恰好包含了 $1$ 到 $r-l+1$ 的所有整数（即构成一个 $1$ 到 $k$ 的排列，其中 $k=r-l+1$）。

#### **输入输出样例**

**输入**
```
5
2 1 3 4 5
```

**输出**
```
3
```
*(符合条件的子数组有 `[1]` (长度1), `[2, 1]` (是1,2的排列), `[2, 1, 3, 4, 5]` (是1..5的排列))*

#### **思路解析**

1.  **条件分析**: 一个子数组 `a[l..r]` 是 `1..k` 的排列，当且仅当同时满足两个条件：
    1.  **唯一性**：数组内所有元素均不相同。
    2.  **范围/最大值**：数组内的最大值恰好等于其长度 $k=r-l+1$。

2.  **哈希作为统一校验**: 我们可以用异或哈希将这两个条件合并成一个校验。
    *   为宇宙中的每个数字 $x$ (这里是 $1..n$) 预先分配一个随机的哈希值 $H(x)$。
    *   子数组 `a[l..r]` 的哈希值为 $H_{sub} = H(a[l]) \oplus \dots \oplus H(a[r])$。
    *   理想排列 `1..k` 的哈希值为 $H_{ideal} = H(1) \oplus \dots \oplus H(k)$。
    *   我们的目标就是寻找满足 $H_{sub} = H_{ideal}$ 的区间 $[l, r]$。

3.  **前缀和表示**:
    *   定义数组a的前缀哈希：$P_a[i] = H(a) \oplus \dots \oplus H(a[i])$。
    *   定义理想排列的前缀哈希：$P_{ideal}[i] = H(1) \oplus \dots \oplus H(i)$。
    *   校验方程变为：$P_a[r] \oplus P_a[l-1] = P_{ideal}[r-l+1]$。

4.  **算法的突破：改变迭代思路**
    *   直接求解上述方程很困难，因为 $l$ 和 $r$ 相互耦合。
    *   **突破口**：**不枚举左右端点，而是枚举区间内的最大值！**
    *   假设 $a[i]$ 是某个我们想找的“完美子数组” `[l, r]` 中的最大值。那么必然有 $a[i] = \text{长度} = r-l+1$，并且对于所有 $j \in [l, r], j \neq i$，必须有 $a[j] < a[i]$。

5.  **最终算法**
    1.  **预处理 (O(N))**:
        *   生成所有数字 $1..N$ 的随机哈希值 $H(x)$。
        *   计算前缀哈希数组 $P_a$ 和 $P_{ideal}$。
        *   使用**单调栈**，对每个位置 $i$，计算出它作为最大值的最大区间范围 $[L_i, R_i]$。
    2.  **主循环 (O(N log N))**:
        *   遍历每个位置 $i$ 从 $1$ 到 $N$。
        *   在以 $i$ 为中心的两个半区间 `[L_i, i]` 和 `[i, R_i]` 中，我们选择**较短**的那个进行枚举，以保证整体复杂度为对数级。
        *   **情况一：左半边 `[L_i, i-1]` 较短**
            *   我们枚举左端点 $l$ 从 $i$ 到 $L_i$。
            *   根据条件 $a[i] = r-l+1$ 直接计算出期望的右端点 $r = l + a[i] - 1$。
            *   检查这个 $r$ 是否在合法范围内（即 $i \le r \le R_i$）。
            *   如果合法，就进行最终的哈希校验：$P_a[r] \oplus P_a[l-1] == P_{ideal}[a[i]]$。
        *   **情况二：右半边 `[i+1, R_i]` 较短**
            *   同理，我们枚举右端点 $r$ 从 $i$ 到 $R_i$。
            *   计算出期望的左端点 $l = r - a[i] + 1$，检查并校验。

#### **代码实现与解读**

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <stack>

using ull = unsigned long long;

// 使用固定的种子以保证每次运行结果一致，便于调试
mt19937_64 mrand_perm(1337);

void solve_permutation() {
    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    
    // 步骤1: 预处理哈希值和前缀和
    std::vector<ull> h(n + 1);
    std::vector<ull> p_ideal(n + 1, 0);
    for(int i = 1; i <= n; ++i) {
        h[i] = mrand_perm();
        p_ideal[i] = p_ideal[i-1] ^ h[i];
    }

    std::vector<ull> p_a(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
        if (a[i] <= n) { // 值大于n的数不可能在1..k的排列中
           p_a[i] = p_a[i-1] ^ h[a[i]];
        } else {
           p_a[i] = p_a[i-1]; // 可以直接忽略，或异或一个特殊的“哨兵”哈希值
        }
    }

    // 步骤2: 使用单调栈计算每个a[i]作为最大值的区间[L, R]
    std::vector<int> left(n + 1), right(n + 1);
    std::stack<int> s;
    for (int i = 1; i <= n; ++i) {
        while (!s.empty() && a[s.top()] < a[i]) {
            s.pop();
        }
        left[i] = s.empty() ? 1 : s.top() + 1;
        s.push(i);
    }
    while(!s.empty()) s.pop(); // 清空栈
    for (int i = n; i >= 1; --i) {
        while (!s.empty() && a[s.top()] < a[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top() - 1;
        s.push(i);
    }

    // 步骤3: 主循环，枚举最大值位置i，在短的一侧枚举端点
    ll ans = 0;
    for (int i = 1; i <= n; ++i) {
        // a[i] 作为区间的最大值，其值必须是区间的长度
        int len = a[i];
        
        // 短边枚举优化
        if (i - left[i] < right[i] - i) {
            // 左边短，枚举左端点 l
            for (int l = i; l >= left[i]; --l) {
                int r = l + len - 1;
                // 检查计算出的右端点r是否在a[i]的统治范围内
                if (r >= i && r <= right[i]) {
                    // 哈希校验
                    if ((p_a[r] ^ p_a[l - 1]) == p_ideal[len]) {
                        ans++;
                    }
                }
            }
        } else {
            // 右边短，枚举右端点 r
            for (int r = i; r <= right[i]; ++r) {
                int l = r - len + 1;
                // 检查计算出的左端点l是否在a[i]的统治范围内
                if (l <= i && l >= left[i]) {
                    // 哈希校验
                    if ((p_a[r] ^ p_a[l - 1]) == p_ideal[len]) {
                        ans++;
                    }
                }
            }
        }
    }
    std::cout << ans << '\n';
}

// 这是一个独立的题目，所以main函数只调用它
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    solve_permutation();
    return 0;
}
```