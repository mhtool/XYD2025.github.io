## 算法竞赛中的计数利器：容斥原理

在算法竞赛中，计数问题是一类常见的题型。当直接计算“恰好”满足某些条件的方案数变得非常复杂时，容斥原理（Principle of Inclusion-Exclusion, PIE）就成了一个强大而优雅的工具。它的核心思想是：先多算，再减掉多算的，再加上被多减的，如此往复，直到得到精确的答案。

### 一、 容斥原理核心思想

#### 1. 原理描述

容斥原理旨在计算多个集合的并集大小。

对于两个集合 $A$ 和 $B$，其并集大小为：
$|A \cup B| = |A| + |B| - |A \cap B|$

对于三个集合 $A, B, C$，公式扩展为：
$|A \cup B \cup C| = |A| + |B| + |C| - (|A \cap B| + |A \cap C| + |B \cap C|) + |A \cap B \cap C|$

推广到 $n$ 个性质 $P_1, P_2, \dots, P_n$，令 $S_i$ 表示具有性质 $P_i$ 的元素构成的集合。我们想要求解至少满足一个性质的元素个数，即 $|\bigcup_{i=1}^{n} S_i|$，其通用公式为：

$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i<j} |S_i \cap S_j| + \sum_{i<j<k} |S_i \cap S_j \cap S_k| - \dots + (-1)^{n-1} |S_1 \cap \dots \cap S_n|$

这个公式可以更紧凑地写成：
$|\bigcup_{i=1}^{n} S_i| = \sum_{\emptyset \neq I \subseteq \{1, \dots, n\}} (-1)^{|I|-1} |\bigcap_{i \in I} S_i|$

#### 2. 解题套路：“恰好”与“至少”的转换

在题目中，我们通常遇到的问题是“恰好满足 $k$ 个条件”或“一个条件都不满足”。容斥原理最强大的应用场景正是将这类复杂的“恰好”问题，转化为更容易计算的“至少”问题。

**常见套路：**
1.  **定义“坏”性质：** 题目通常要求满足一组“好”的条件。我们可以反其道而行之，定义一组“坏”的性质 $P_i$（即不满足第 $i$ 个好条件）。
2.  **设定目标：** 我们的目标就变成了计算 **一个“坏”性质都不满足** 的方案数。
3.  **应用容斥：** 设 $U$ 为全集（总方案数），$S_i$ 为满足“坏”性质 $P_i$ 的方案集合。我们要求解的是：
    $|U| - |\bigcup_{i=1}^{n} S_i|$
    根据上述公式展开即可。这个过程可以理解为：
    *   从总方案数开始。
    *   减去“至少满足一个坏性质”的方案数 ($\sum |S_i|$）。
    *   加上“至少满足两个坏性质”的方案数 ($\sum |S_i \cap S_j|$）。
    *   减去“至少满足三个坏性质”的方案数 ($\sum |S_i \cap S_j \cap S_k|$）。
    *   ... 以此类推，交替加减。

### 二、 经典例题解析

#### 例题1：错排问题 (Derangement)

**题目描述**
$n$ 个编号为 $1, 2, \dots, n$ 的元素进行排列，要求每个元素都不在自己原来的位置上。求总共有多少种合法的排列方式？

**数据范围**
$1 \le n \le 10^6$

**样例**
输入：$n = 3$
输出：2
解释：对于序列 $(1, 2, 3)$，合法的错排为 $(2, 3, 1)$ 和 $(3, 1, 2)$。

**题解思路**
这是一个典型的“所有条件都不满足”的问题。
*   **总方案数 ($|U|$)：** 如果没有任何限制，总的排列方案数为 $n!$。
*   **定义“坏”性质：** 定义第 $i$ 个“坏”性质 $P_i$ 为“第 $i$ 个元素恰好在第 $i$ 个位置上”。
*   **目标：** 我们要求解的是一个“坏”性质都不满足的方案数。
*   **应用容斥原理：**
    *   **至少满足1个坏性质：** 考虑让某1个元素（例如第 $i$ 个）在原位。有 $\binom{n}{1}$ 种方式选择这个元素。剩下 $n-1$ 个元素任意排列，有 $(n-1)!$ 种方式。总方案数为 $\binom{n}{1} (n-1)!$。
    *   **至少满足2个坏性质：** 选择2个元素在原位，有 $\binom{n}{2}$ 种方式。剩下 $n-2$ 个元素任意排列，有 $(n-2)!$ 种方式。总方案数为 $\binom{n}{2} (n-2)!$。
    *   **至少满足k个坏性质：** 同理，方案数为 $\binom{n}{k} (n-k)!$。

根据容斥原理，最终的错排数 $D_n$ 为：
$D_n = n! - \binom{n}{1}(n-1)! + \binom{n}{2}(n-2)! - \dots + (-1)^n \binom{n}{n}(n-n)!$

化简 $\binom{n}{k}(n-k)! = \frac{n!}{k!(n-k)!}(n-k)! = \frac{n!}{k!}$，得到：
$D_n = \frac{n!}{0!} - \frac{n!}{1!} + \frac{n!}{2!} - \dots + (-1)^n \frac{n!}{n!} = n! \sum_{i=0}^{n} \frac{(-1)^i}{i!}$

**题解代码 (C++)**
```cpp
#include <iostream>
#include <vector>

const int N = 1e6 + 5;

int fac[N], inv[N];

const int mod = 1e9 + 7;

int q_pow(int x, int p)
{
    int res = 1;
    for (; p; x = 1ll * x * x % mod, p >>= 1)
        if (p & 1)
            res = 1ll * res * x % mod;
    return res;
}

int get_inv(int x)
{
    return q_pow(x, mod - 2);
}

void init_fac(int n)
{
    fac[0] = 1;
    for (int i = 1; i <= n; ++i)
        fac[i] = 1ll * fac[i - 1] * i % mod;
    inv[n] = get_inv(fac[n]);
    for (int i = n - 1; i >= 0; --i)
        inv[i] = 1ll * (i + 1) * inv[i + 1] % mod;

}

int comb(int n, int k)
{
    if (k < 0 || k > n) return 0;
    return 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;
}

int main()
{
    init_fac();
    int n;
    cin >> n;
    int ans = 0;
    for (int i = 0; i <= n; ++i)
    {
        int now = 1ll * comb(n, i) * fac[n - i] % mod;
        if (i % 2 == 1)
            ans = (ans + mod - term) % mod;
        else
            ans = (ans + term) % mod;
    }
    cout << ans << endl;
    return 0;
}
```
---

#### 例题2：蓝桥杯2024国A - gcd 与 lcm (P10580)

**题目描述**
给定两个数 $x, y$ 和一个整数 $n$，求有多少种不同的长度为 $n$ 的序列 $(a_1, a_2, \dots, a_n)$，其所有元素的最大公约数 ($\gcd$) 为 $x$，且最小公倍数 ($\text{lcm}$) 为 $y$。由于答案可能很大，请输出答案对 $998244353$ 取模后的结果。

**数据范围**
$1 \le Q \le 1000, 1 \le x, y, n \le 10^9$

**题解思路**
这是一个“恰好”满足两个复杂条件的计数问题。

1.  **问题简化：**
    *   一个必要条件是 $y$ 必须是 $x$ 的倍数。如果 $y \pmod x \neq 0$，则不存在这样的序列，答案为 0。
    *   如果 $y \pmod x == 0$，我们可以对序列中的每个数都除以 $x$。令 $b_i = a_i / x$ 和 $Y = y / x$。问题转化为：
        求有多少长度为 $n$ 的序列 $(b_1, \dots, b_n)$，使得 $\gcd(b_1, \dots, b_n) = 1$ 且 $\text{lcm}(b_1, \dots, b_n) = Y$。
    *   同时，由于 $a_i$ 的 $\text{lcm}$ 是 $y$，每个 $a_i$ 必须是 $y$ 的约数。同理，每个 $b_i$ 必须是 $Y$ 的约数。

2.  **按质因子独立分析：**
    数论问题可以按质因子分解，将问题分解到每个质数上独立计算，最后将结果相乘。
    *   令 $Y$ 的质因子分解为 $Y = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m}$。
    *   对于序列中的每个数 $b_j$，其质因子分解为 $b_j = p_1^{e_{j,1}} p_2^{e_{j,2}} \cdots p_m^{e_{j,m}}$。
    *   因为 $b_j$ 是 $Y$ 的约数，所以对于每个质因子 $p_i$，其指数 $e_{j,i}$ 必须满足 $0 \le e_{j,i} \le k_i$。
    *   $\gcd(b_1, \dots, b_n) = 1$ 等价于对每个质因子 $p_i$，$\min(e_{1,i}, e_{2,i}, \dots, e_{n,i}) = 0$。
    *   $\text{lcm}(b_1, \dots, b_n) = Y$ 等价于对每个质因子 $p_i$，$\max(e_{1,i}, e_{2,i}, \dots, e_{n,i}) = k_i$。

3.  **对每个质因子使用容斥原理：**
    现在问题变成了：对于每个质因子 $p_i$ (其在 $Y$ 中的指数为 $k_i$)，计算有多少个长度为 $n$ 的指数序列 $(e_{1,i}, \dots, e_{n,i})$，同时满足以下两个条件：
    *   **条件A:** $\min(e_{j,i}) = 0$
    *   **条件B:** $\max(e_{j,i}) = k_i$

    这是一个典型的二维容斥问题。
    *   **总方案数 ($|U|$)：** 每个 $e_{j,i}$ 可以在 $[0, k_i]$ 中任选，有 $k_i + 1$ 种选择。总共有 $(k_i + 1)^n$ 种方案。
    *   **定义“坏”性质：**
        *   性质 U' (违反条件A): $\min(e_{j,i}) > 0$。这意味着所有 $e_{j,i}$ 都在 $[1, k_i]$ 中选择，有 $k_i^n$ 种方案。
        *   性质 V' (违反条件B): $\max(e_{j,i}) < k_i$。这意味着所有 $e_{j,i}$ 都在 $[0, k_i-1]$ 中选择，有 $k_i^n$ 种方案。
    *   **应用容斥原理：**
        我们要求的是 `总数 - (满足U' 或 满足V' 的方案数)`。
        $|U' \cup V'| = |U'| + |V'| - |U' \cap V'|$
        *   $|U' \cap V'|$：同时满足 $\min(e_{j,i}) > 0$ 和 $\max(e_{j,i}) < k_i$。这意味着所有 $e_{j,i}$ 都在 $[1, k_i-1]$ 中选择。当 $k_i > 1$ 时，有 $(k_i - 1)^n$ 种方案；当 $k_i = 1$ 时，区间为空，有 $0$ 种方案。
        *   所以，对于质因子 $p_i$，合法的指数序列数量为：
            $|U| - (|U'| + |V'| - |U' \cap V'|)$
            $= (k_i + 1)^n - (k_i^n + k_i^n - (k_i - 1)^n)$
            $= (k_i + 1)^n - 2 k_i^n + (k_i - 1)^n$

4.  **最终答案：**
    将每个质因子算出的方案数相乘即可。
    *   对 $Y$ 进行质因子分解。
    *   对每个质因子 $p_i$ 及其指数 $k_i$，计算 $((k_i + 1)^n - 2k_i^n + (k_i - 1)^n) \pmod{998244353}$。
    *   将所有结果乘起来，即为最终答案。

**题解代码 (C++)**
```cpp
#include <iostream>
#include <vector>
#include <map>

using namespace std;

long long power(long long base, long long exp) {
    long long res = 1;
    long long MOD = 998244353;
    base %= MOD;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

map<long long, int> get_prime_factorization(long long num) {
    map<long long, int> factors;
    for (long long i = 2; i * i <= num; ++i) {
        if (num % i == 0) {
            while (num % i == 0) {
                factors[i]++;
                num /= i;
            }
        }
    }
    if (num > 1) factors[num]++;
    return factors;
}

void solve() {
    long long x, y, n;
    cin >> x >> y >> n;

    if (y % x != 0) {
        cout << 0 << endl;
        return;
    }

    long long Y = y / x;
    if (Y == 1) { // 特殊情况: gcd=1, lcm=1, 只有全1序列
        cout << 1 << endl;
        return;
    }
    map<long long, int> factors = get_prime_factorization(Y);

    long long ans = 1;
    long long MOD = 998244353;

    for (auto const& [p, k] : factors) {
        long long term1 = power(k + 1, n);
        long long term2 = (2 * power(k, n)) % MOD;
        long long term3 = power(k - 1, n);

        long long count_for_p = (term1 - term2 + MOD) % MOD;
        count_for_p = (count_for_p + term3) % MOD;
        
        ans = (ans * count_for_p) % MOD;
    }

    cout << ans << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int q;
    cin >> q;
    while (q--) {
        solve();
    }
    return 0;
}
```

### 三、 更多经典例题

#### 例题3：能被整除的数

**题目描述**
给定一个整数 $N$ 和一个 $m$ 个不同质数的集合 $P = \{p_1, p_2, \dots, p_m\}$。求在 $[1, N]$ 的整数中，有多少个数能被 $P$ 中至少一个质数整除。

**数据范围**
$1 \le N \le 10^{18}, 1 \le m \le 20$

**样例**
输入: $N = 20, P = \{2, 3\}$
输出: 13
解释: 区间 $[1, N]$ 中能被 $2$ 或 $3$ 整除的数有: $2, 3, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20$。共 $13$ 个。

**题解思路**
这是容斥原理最直接的应用。
*   **定义性质：** 定义性质 $A_i$ 为“能被 $p_i$ 整除”。
*   **目标：** 计算 $|\bigcup_{i=1}^{m} A_i|$。
*   **应用容斥原理：**
    *   在 $[1, N]$ 中，能被 $d$ 整除的数的个数是 $\lfloor N/d \rfloor$。
    *   $|A_i| = \lfloor N/p_i \rfloor$
    *   $|A_i \cap A_j| = \lfloor N/(p_i \cdot p_j) \rfloor$ （因为 $p_i, p_j$ 是不同质数）
    *   $|\bigcap_{i \in I} A_i| = \lfloor N / \prod_{i \in I} p_i \rfloor$

    根据容斥原理公式：
    $Ans = \sum_{i} \lfloor \frac{N}{p_i} \rfloor - \sum_{i<j} \lfloor \frac{N}{p_i p_j} \rfloor + \dots$

    我们可以通过枚举 $P$ 的所有非空子集来实现。一个大小为 $k$ 的子集，其元素的乘积记为 $d_k$。如果 $k$ 是奇数，我们就加上 $\lfloor N/d_k \rfloor$；如果 $k$ 是偶数，我们就减去 $\lfloor N/d_k \rfloor$。

    由于 $m$ 很小 ($m \le 20$)，我们可以用一个 $m$ 位的二进制数（从 $1$ 到 $2^m-1$）来代表 $P$ 的所有非空子集。

**题解代码 (C++)**
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    long long n;
    int m;
    cin >> n >> m;
    vector<long long> p(m);
    for (int i = 0; i < m; ++i) {
        cin >> p[i];
    }

    long long ans = 0;
    // 遍历所有非空子集，i 从 1 到 2^m - 1
    for (int i = 1; i < (1 << m); ++i) {
        long long d = 1;
        int set_bits = 0; // 子集中元素的个数
        for (int j = 0; j < m; ++j) {
            // 检查第 j 位是否为 1
            if ((i >> j) & 1) {
                // 防止乘法溢出
                if ((double)d * p[j] > n + 5) { 
                    d = n + 1; // 标记为超大数，使得 N/d = 0
                    break;
                }
                d *= p[j];
                set_bits++;
            }
        }

        if (set_bits % 2 == 1) { // 奇数个元素，加
            ans += n / d;
        } else { // 偶数个元素，减
            ans -= n / d;
        }
    }

    cout << ans << endl;

    return 0;
}
```