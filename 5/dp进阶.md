
### **一、 状压DP (状态压缩动态规划)**

#### **1. 什么是状压DP？我们什么时候会想到它？**

状压DP，本质上依然是动态规划，它的特殊之处在于**状态的表示**。当一个问题的状态可以被描述为一个集合时（比如棋盘上一行的摆放、任务的完成情况），如果这个集合的元素数量不多，我们就应该立刻警觉。

**识别信号**：
*   **数据范围极小**：问题中的某个关键维度 $N$ 特别小，通常 $N \le 20$。这是最强的信号，因为 $2^{20} \approx 10^6$，以它为状态总数是可以在1秒内完成计算的。
*   **集合性质的状态**：题目需要记录一个“集合”的性质。例如，“哪些点已经被访问过了”、“哪些位置已经放了东西”、“哪些任务已经完成”。
*   **元素状态简单**：集合中的每个元素只有两种（或很少几种）状态，比如“选/没选”、“放/没放”。

**核心思想**：用一个**整数**的二进制位来“压缩”这个集合状态，从而以整数为DP数组的维度进行状态转移。

#### **2. 核心武器库：位运算 与 子集枚举**

要玩转状压DP，必须熟练掌握位运算。

*   **基本操作:**
    *   获取整数 `s` 的第 `i` 位：`(s >> i) & 1`
    *   将整数 `s` 的第 `i` 位设为1：`s | (1 << i)`
    *   将整数 `s` 的第 `i` 位设为0：`s & (~(1 << i))`
    *   将整数 `s` 的第 `i` 位取反：`s ^ (1 << i)`

*   **常用技巧:**
    *   **判断状态冲突**：检查状态 `s1` 和 `s2` 是否在同一位置都为1（例如，上下相邻的棋子），使用 `(s1 & s2) == 0` 来判断是否**不冲突**。
    *   **检查自身合法性**：检查状态 `s` 是否有相邻的1（例如，左右相邻的棋子），使用 `(s & (s << 1)) == 0` 来判断是否**不相邻**。
    *   **统计状态中1的个数 (lowbit)**：`int count = 0; while(s > 0) { s -= (s & -s); count++; }`。

*   **高效子集枚举 (进阶技巧):**
    有时候，我们需要枚举一个状态 `s` 的所有二进制子集。最高效的技巧是：
    ```cpp
    for (int sub = s; sub; sub = (sub - 1) & s) {
        // 'sub' 在这里就是 's' 的一个非空子集
    }
    ```
    **简单证明**：`sub - 1` 的效果是在`sub`的二进制表示中，将最右边的`1`变成`0`，并把这个`1`右边的所有`0`都变成`1`。再 `& s`，这个操作会把所有因借位而多出来的`1`（那些不在原集合`s`中的位）全部清零，从而精确地得到`s`的下一个字典序更小的子集。

#### **3. 经典排列型例题：旅行商问题 (TSP)**

**题目描述**
有 $n$ 个城市，给定城市间的距离矩阵 $dist[i][j]$。一个商人要从城市 $0$ 出发，访问所有城市恰好一次，最后回到城市 $0$。求最短的旅行路径长度。

**输入格式**
第一行一个整数 $n$ ($1 \le n \le 16$)  
接下来 $n$ 行，每行 $n$ 个整数，表示距离矩阵 $dist[i][j]$

**输出格式**
一个整数，表示最短的旅行路径长度。

**数据范围**
- $1 \le n \le 16$
- $0 \le dist[i][j] \le 10^5$
- $dist[i][j] = dist[j][i]$（距离矩阵对称）
- $dist[i][i] = 0$（城市到自己的距离为0）

**样例输入**
```
4
0 10 15 20
10 0 35 25
15 35 0 30
20 25 30 0
```

**样例输出**
```
80
```

**样例解释**
最短路径为：$0 \to 1 \to 3 \to 2 \to 0$，总长度为 $10 + 25 + 30 + 15 = 80$。

**解题思路**
$n \le 16$ 是状压DP的典型信号。这个问题的关键在于：我们需要记录**当前所在的城市**和**已经访问过的城市集合**。

*   **状态定义**: $dp[i][S]$ 表示当前在城市 $i$，已经访问过城市集合 $S$（$S$ 中包含城市 $i$）的最短路径长度。
*   **状态转移**: 要到达状态 $dp[i][S]$，我们必须从某个城市 $j$ 转移过来，其中 $j \in S$ 且 $j \neq i$。
    $$dp[i][S] = \min_{j \in S, j \neq i} \{ dp[j][S \setminus \{i\}] + dist[j][i] \}$$
*   **初始化**: $dp[0][1] = 0$，表示从城市 $0$ 开始，只访问了城市 $0$，路径长度为 $0$。
*   **最终答案**: $\min_{i=1}^{n-1} \{ dp[i][(1<<n)-1] + dist[i][0] \}$，表示访问完所有城市后，从任意城市 $i$ 回到起点 $0$ 的最短路径。

**C++ 代码实现**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int INF = 0x3f3f3f3f;

int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> dist(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> dist[i][j];
        }
    }
    
    // dp[i][S] = 当前在城市i，访问过集合S的最短路径
    vector<vector<int>> dp(n, vector<int>(1 << n, INF));
	
    // 初始化：从城市0开始
    dp[0][1] = 0;  // 二进制 1 表示只访问了城市0
    
    // 枚举所有状态集合
    for (int S = 1; S < (1 << n); S++) { // 枚举当前所在的城市
        for (int i = 0; i < n; i++) { // 如果城市i不在集合S中，跳过
            if (!(S & (1 << i))) continue; // 如果dp[i][S]还没有被更新过，跳过
            if (dp[i][S] == INF) continue; // 枚举下一个要访问的城市
            for (int j = 0; j < n; j++) { // 如果城市j已经在集合S中，跳过
                if (S & (1 << j)) continue;
                
                // 状态转移：从城市i到城市j
                int new_S = S | (1 << j);
                dp[j][new_S] = min(dp[j][new_S], dp[i][S] + dist[i][j]);
            }
        }
    }
    
    // 计算最终答案：从任意城市回到起点0
    int ans = INF;
    int all_visited = (1 << n) - 1;  // 所有城市都被访问过
    
    for (int i = 1; i < n; i++) {
        if (dp[i][all_visited] != INF) {
            ans = min(ans, dp[i][all_visited] + dist[i][0]);
        }
    }
    
    cout << ans << endl;
    return 0;
}
```

**状态转移的关键理解**
1.  **维度含义**: 
    *   `i` 维度：表示**当前位置**，即排列的最后一位
    *   `S` 维度：表示**已访问集合**，即当前排列中包含的所有元素
2.  **转移方向**: 从小集合向大集合转移，每次向集合中添加一个新元素
3.  **边界条件**: 只有起点的单元素集合状态被初始化为有效值

**复杂度分析**
*   时间复杂度：$O(n^2 \cdot 2^n)$，状态数 $n \cdot 2^n$，每个状态的转移需要 $O(n)$ 时间
*   空间复杂度：$O(n \cdot 2^n)$，存储所有状态

这个例题完美展示了 `dp[i][S]` 形式的状压DP，其中 `i` 代表排列的最后一位，`S` 代表集合状态。

#### **4. 经典二维例题：互不侵犯的国王 (K-Kings)**

**题目描述**
在 $N \times N$ 的棋盘上，要放置 $K$ 个国王，要求任意两个国王不能互相攻击（国王一步内能到达与之八连通的位置）。求所有合法的放置方案数。

**输入格式**
一行两个整数 $N$ 和 $K$，用空格分隔。

**输出格式**
一个整数，表示合法的放置方案数。

**数据范围**
- $1 \le N \le 9$
- $0 \le K \le N \times N$

**样例输入**
```
3 2
```

**样例输出**
```
16
```

**样例解释**
在 $3 \times 3$ 的棋盘上放置 $2$ 个国王，使得它们不能互相攻击的方案数为 $16$ 种。

**解题思路**
$N \le 9$ 是状压信号。这题比“玉米田”多了一个限制：国王的总数 $K$。因此，我们的DP状态需要增加一维。
*   **状态定义**: $dp[i][S][k]$ 表示已经处理完前 $i$ 行，第 $i$ 行的摆放状态为 $S$，且整个棋盘（前 $i$ 行）总共已经放置了 $k$ 个国王时的方案数。
*   **状态转移**:
    $dp[i][S_{cur}][k] = \sum dp[i-1][S_{prev}][k - \text{count}(S_{cur})]$
    兼容条件：
    1.  $S_{cur}$ 自身合法：左右不相邻 `(S_cur & (S_cur << 1)) == 0`
    2.  与 $S_{prev}$ 兼容：上下、左上、右上均不相邻。 `(S_cur & S_prev) == 0 && (S_cur & (S_prev << 1)) == 0 && (S_cur & (S_prev >> 1)) == 0`

**C++ 代码实现**
```cpp
#include <iostream>
#include <vector>
#include <numeric>

// dp[当前行i][当前行状态S][已用国王数k]
long long dp[10][1 << 9][82]; 
std::vector<int> valid_states; // 预处理存储所有单行合法的状态
std::vector<int> king_counts;  // 存储每个合法状态的国王数

// 辅助函数：计算一个整数二进制中1的个数
int count_ones(int n) {
    int count = 0;
    while (n > 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

int main() {
    int n, K;
    std::cin >> n >> K;

    // 预处理所有单行合法的状态 (国王不能左右相邻)
    for (int i = 0; i < (1 << n); ++i) {
        if ((i & (i << 1)) == 0) {
            valid_states.push_back(i);
            king_counts.push_back(count_ones(i));
        }
    }

    dp[0][0][0] = 1; // 哨兵：第0行（虚拟）状态为0，国王数为0，方案数为1

    for (int i = 1; i <= n; ++i) {        // 遍历行
        for (int k = 0; k <= K; ++k) {    // 遍历总国王数
            // 遍历当前行 i 的所有合法状态
            for (size_t s_idx = 0; s_idx < valid_states.size(); ++s_idx) {
                int cur_s = valid_states[s_idx];
                int num_cur = king_counts[s_idx];
                if (k < num_cur) continue; // 当前国王数不够放，跳过

                // 遍历上一行 i-1 的所有合法状态，进行转移
                for (size_t p_idx = 0; p_idx < valid_states.size(); ++p_idx) {
                    int prev_s = valid_states[p_idx];
                    
                    // 检查兼容性：上下、左上、右上均不冲突
                    if ((cur_s & prev_s) == 0 &&
                        (cur_s & (prev_s << 1)) == 0 &&
                        (cur_s & (prev_s >> 1)) == 0) {
                        // 累加方案数
                        dp[i][cur_s][k] += dp[i - 1][prev_s][k - num_cur];
                    }
                }
            }
        }
    }

    long long ans = 0;
    // 最终答案是第N行，用满K个国王的所有状态的方案数之和
    for (size_t s_idx = 0; s_idx < valid_states.size(); ++s_idx) {
        ans += dp[n][valid_states[s_idx]][K];
    }
    std::cout << ans << std::endl;
    return 0;
}
```

#### **5. 进阶技巧：子集枚举DP (3^n 复杂度)**

在状压DP中，有一类特殊的问题需要**对每个状态枚举其所有子集**。这类问题的复杂度通常是 $O(3^n)$，因为：
$$\sum_{S \subseteq \{1,2,\ldots,n\}} 2^{|S|} = \sum_{k=0}^{n} \binom{n}{k} 2^k = (1+2)^n = 3^n$$

**识别信号**：
*   需要对每个集合 $S$，考虑如何将 $S$ 分成两个不相交的子集。
*   状态转移形如：$dp[S] = \min_{T \subseteq S} \{dp[T] + dp[S \setminus T] + cost(T, S \setminus T)\}$

---

### **二、 区间DP**

#### **1. 什么是区间DP？我们什么时候会想到它？**

区间DP是一种作用于**线性序列**上，通常解决**相邻元素合并**问题的DP模型。
**识别信号**:
*   问题背景是一个线性序列（数组、字符串等）。
*   核心操作是将**相邻**的两个（或多个）元素合并，并产生一个代价。
*   问题求解的是一个区间的最终最优代价。
*   具有**最优子结构**性质：一个大区间的最优解，可以由其内部的小区间的最优解推导出来。

#### **2. 核心思路：从递归到递推的思维之桥**

区间DP的灵魂在于，**一个区间 $[i, j]$ 的问题，最后一步一定是将它分成了两个相邻的子区间 $[i, k]$ 和 $[k+1, j]$ 进行合并**。这个结构天然地导向了递归（记忆化搜索），而递推只是它的非递归实现。

#### **3. 经典入门例题：石子合并**

**题目描述**
有 $N$ 堆石子排成一排。每次可以合并**相邻**的两堆石子，合并的代价为这两堆石子的总数。求将所有石子合并成一堆的最小总代价。

**输入格式**
第一行一个整数 $N$，表示石子堆数。  
第二行 $N$ 个整数，表示每堆石子的数量。

**输出格式**
一个整数，表示最小总代价。

**数据范围**
- $1 \le N \le 300$
- $1 \le$ 每堆石子数量 $\le 1000$

**样例输入**
```
4
1 3 5 2
```

**样例输出**
```
22
```

**样例解释**
一种最优的合并方案：
1. 合并第1、2堆：代价为 $1+3=4$，剩余 $[4, 5, 2]$
2. 合并第2、3堆：代价为 $5+2=7$，剩余 $[4, 7]$
3. 合并第1、2堆：代价为 $4+7=11$，剩余 $[11]$
总代价为 $4+7+11=22$。

**思路历程1：记忆化搜索 (自顶向下)**
这是最符合人类直觉的思考方式。我们定义一个函数 `solve(i, j)` 来计算合并区间 `[i, j]` 的最小代价。
*   **Base Case**: 如果 `i == j`，只有一堆，不需要合并，代价是0。
*   **Recursive Step**: 对于区间 `[i, j]`，我们枚举最后一次合并的分割点 `k` (从`i`到`j-1`)。总代价就是 `solve(i, k)` + `solve(k+1, j)` + `cost`。这里的 `cost` 是把 `[i, k]` 和 `[k+1, j]` 这两大堆合并的代价，也就是 `[i, j]` 区间内所有石子的总和。
*   **记忆化**: 我们会发现 `solve(2,3)` 这样的子问题会被多次计算，所以用一个 `memo[i][j]` 数组存下结果，避免重复计算。

**记忆化搜索 C++ 代码**
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cstring> // for memset

const int INF = 0x3f3f3f3f;
int n;
std::vector<int> sum;
int memo[301][301];

int get_sum(int i, int j) {
    return sum[j] - sum[i - 1];
}

int solve(int i, int j) {
    if (i >= j) return 0; // base case: 区间为空或只有一个元素
    if (memo[i][j] != -1) return memo[i][j]; // 已经计算过，直接返回

    int min_cost = INF;
    // 枚举分割点k
    for (int k = i; k < j; ++k) {
        min_cost = min(min_cost, solve(i, k) + solve(k + 1, j) + get_sum(i, j));
    }
    return memo[i][j] = min_cost;
}

int main() {
    std::cin >> n;
    sum.resize(n + 1, 0);
    memset(memo, -1, sizeof(memo));
    for (int i = 1; i <= n; ++i) {
        int stone;
        std::cin >> stone;
        sum[i] = sum[i - 1] + stone;
    }
    std::cout << solve(1, n) << std::endl;
    return 0;
}
```

**思路历程2：递推 (自底向上)**
观察上面的递归过程，我们发现，要想计算长度为 `len` 的区间，必须先知道所有长度比 `len` 小的区间的答案。这启发我们，可以反过来，从小区间开始算，直到算出整个大区间。
*   **循环顺序**: 先枚举**区间长度 `len`** 从2到N，再枚举区间的**起点 `i`**。这样能保证在计算 `dp[i][j]` 时，所有它需要用到的 `dp[i][k]` 和 `dp[k+1][j]` 都已经被算出来了。

**递推 C++ 代码**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int INF = 0x3f3f3f3f;

int main() {
    int n;
    std::cin >> n;
    
    std::vector<int> sum(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        int stone;
        std::cin >> stone;
        sum[i] = sum[i - 1] + stone;
    }
    
    // dp[i][j] = 合并区间[i, j]的最小代价
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));
    
    // 枚举区间长度，从2开始（长度为1的区间代价为0）
    for (int len = 2; len <= n; ++len) {
        // 枚举区间起点
        for (int i = 1; i + len - 1 <= n; ++i) {
            int j = i + len - 1;
            dp[i][j] = INF;
            
            // 枚举分割点k
            for (int k = i; k < j; ++k) {
                dp[i][j] = std::min(dp[i][j], 
                    dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]);
            }
        }
    }
    
    std::cout << dp[1][n] << std::endl;
    return 0;
}
```

#### **4. 进阶练习：点气球**

**题目描述**
有 $N$ 个气球排成一排。戳破气球 $i$ 能得到 $nums[i-1] \times nums[i] \times nums[i+1]$ 的分数（边界外的气球数字视为1）。求能获得的最大总分数。

**输入格式**
第一行一个整数 $N$，表示气球数量。  
第二行 $N$ 个整数，表示每个气球的数字。

**输出格式**
一个整数，表示能获得的最大总分数。

**数据范围**
- $1 \le N \le 500$
- $0 \le nums[i] \le 100$

**样例输入**
```
4
3 1 5 8
```

**样例输出**
```
167
```

**样例解释**
最优戳破顺序：
1. 戳破气球1（数字1）：得分 $3 \times 1 \times 5 = 15$
2. 戳破气球2（数字5）：得分 $3 \times 5 \times 8 = 120$
3. 戳破气球0（数字3）：得分 $1 \times 3 \times 8 = 24$
4. 戳破气球3（数字8）：得分 $1 \times 8 \times 1 = 8$
总分数为 $15 + 120 + 24 + 8 = 167$。

**解题思路**
正向思考（先戳哪个）有后效性，因为戳破一个后，它两边的气球就相邻了，状态会改变。
正确的思路是**逆向思考**：在区间 `(i, j)` (开区间) 里，**最后一个被戳破的气球是哪个？**
*   **状态定义**: $dp[i][j]$ 表示戳破开区间 $(i, j)$ 内所有气球能获得的最大分数。
*   **状态转移**: 假设最后戳破的是气球 $k$ ($i<k<j$)。当戳破 $k$ 时，它左右两边一定是气球 $i$ 和 $j$。戳 $k$ 的得分是 $nums[i] \times nums[k] \times nums[j]$。在此之前，我们已经获得了戳完 `(i, k)` 和 `(k, j)` 区间所有气球的得分。
    $dp[i][j] = \max_{i<k<j} \{ dp[i][k] + dp[k][j] + nums[i] \times nums[k] \times nums[j] \}$

**递推 C++ 代码**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n;
    std::cin >> n;
    
    // 在两端添加虚拟气球，值为1
    std::vector<int> nums(n + 2);
    nums[0] = nums[n + 1] = 1;
    for (int i = 1; i <= n; ++i) {
        std::cin >> nums[i];
    }
    
    // dp[i][j] = 戳破开区间(i, j)内所有气球的最大得分
    std::vector<std::vector<int>> dp(n + 2, std::vector<int>(n + 2, 0));
    
    // 枚举区间长度，从3开始（开区间(i, j)内至少有一个气球）
    for (int len = 3; len <= n + 2; ++len) {
        // 枚举区间起点
        for (int i = 0; i + len - 1 <= n + 1; ++i) {
            int j = i + len - 1;
            
            // 枚举最后戳破的气球k
            for (int k = i + 1; k < j; ++k) {
                dp[i][j] = std::max(dp[i][j], 
                    dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);
            }
        }
    }
    
    std::cout << dp[0][n + 1] << std::endl;
    return 0;
}
```

#### **5. 边界类型区间DP：游戏王问题**

前面我们学习的石子合并和戳气球都属于**"合并模型"**的区间DP，需要枚举分界点`k`。现在我们来学习另一种重要的区间DP模式——**"边界模型"**或**"收缩模型"**。

**题目描述**
大哈是个游戏王，尽管他的水平一言难尽，但他却总是这样自我称呼。小羽说如果你能把这个游戏通关了，你才算是个真的游戏王。这个游戏一开始你有n个连在一起的颜色块，第i个颜色块的颜色为ai。如果从倒的颜色都一样，就说明倒属于同一个连通块。比如[5,5,5]属于同一个连通块，[4,3,9,9]有3个连通块。游戏开始前大哈可以选择任意一个位置作为起始点，然后开始游戏。游戏的每一轮大哈可以将包含起始点的连通块的颜色变成任意一种其他的颜色。问大哈能将整个数组变成从1到n的连通块所需要的最少回合数。

**输入格式**
第一行一个整数n (1 ≤ n ≤ 5000)  
第二行n个整数ai (1 ≤ ai ≤ 5000)

**输出格式**
一个整数，表示最少回合数。

**数据范围**
- 1 ≤ n ≤ 5000
- 1 ≤ ai ≤ 5000

**样例输入**
```
8
1 2 2 2 3 3 2 1
```

**样例输出**
```
2
```

**解题思路**

**与传统区间DP的区别**

这道题的核心在于理解它与传统"合并模型"区间DP的不同：

| 特征 | 合并模型 (如石子合并) | 边界模型 (如本题) |
| :--- | :--- | :--- |
| **问题核心** | 将两个已解决的子问题合并成一个大问题 | 通过处理边界，将大问题简化成小问题 |
| **状态来源** | `dp[i][k]` 和 `dp[k+1][j]` | `dp[i+1][j]`, `dp[i][j-1]`, `dp[i+1][j-1]` |
| **是否需要枚举 `k`** | **是**，因为需要找到最优的合并点 | **否**，因为决策只在边界上发生 |
| **常见问题类型** | 组合、划分问题 | 回文串、括号匹配、消除类问题 |

**算法步骤**

1. **预处理**：将连续相同的元素合并。例如`[1,2,2,2,3,3,2]`变成`[1,2,3,2]`
2. **状态定义**：`dp[i][j]`表示将区间`[i,j]`变成同一种颜色的最少操作次数
3. **状态转移**：
   - 如果$a[i] == a[j]$：$dp[i][j] = dp[i+1][j-1] + 1$
   - 如果$a[i] \neq a[j]$：$dp[i][j] = \min(dp[i+1][j], dp[i][j-1]) + 1$

**关键洞察**

当两端颜色相同时($a[i] == a[j]$)，我们可以：
1. 先处理中间部分$[i+1, j-1]$，用$dp[i+1][j-1]$次操作统一颜色
2. 再用1次操作将中间的颜色变成两端的颜色
3. 这样整个区间就统一了，总代价是$dp[i+1][j-1] + 1$

```cpp
int solve(int l, int r)
{
	if (a[l] == a[r])
		ans = min(ans, solve(l + 1, r - 1) + 1);
	ans = min(ans, min(solve(l + 1, r), solve(l, r - 1)) + 1);
	return ans;
}
```
**C++ 代码实现**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n;
    std::cin >> n;
    
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
    }
    
    // 预处理：去除连续相同元素
    a.erase(std::unique(a.begin() + 1, a.end()), a.end());
    n = a.size() - 1;
    
    // dp[i][j] = 将区间[i,j]变成同一种颜色的最少操作次数
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));
    
    // 初始化：单个元素不需要操作
    for (int i = 1; i <= n; ++i) {
        dp[i][i] = 0;
    }
    
    // 枚举区间长度
    for (int len = 2; len <= n; ++len) {
        // 枚举区间起点
        for (int i = 1; i + len - 1 <= n; ++i) {
            int j = i + len - 1;
            
            if (a[i] == a[j]) {
                // 两端颜色相同的优化情况
                dp[i][j] = dp[i + 1][j - 1] + 1;
            } else {
                // 两端颜色不同，选择较优的边界处理策略
                dp[i][j] = std::min(dp[i + 1][j], dp[i][j - 1]) + 1;
            }
        }
    }
    
    std::cout << dp[1][n] << std::endl;
    return 0;
}
```

**复杂度分析**
- 时间复杂度：$O(n^2)$，两层循环枚举所有区间
- 空间复杂度：$O(n^2)$，存储DP状态

**样例分析**
原数组：`[1,2,2,2,3,3,2]`
预处理后：`[1,2,3,2]`

计算过程：
- `dp[1][1] = dp[2][2] = dp[3][3] = dp[4][4] = 0`
- `dp[1][2] = dp[2][3] = dp[3][4] = 1`（相邻不同颜色）
- `dp[2][4] = dp[2+1][4-1] + 1 = dp[3][3] + 1 = 1`（两端相同）
- `dp[1][3] = min(dp[2][3], dp[1][2]) + 1 = 2`
- `dp[1][4] = min(dp[2][4], dp[1][3]) + 1 = min(1, 2) + 1 = 2`

但由于题目允许选择任意起始点，实际最优解是3次操作。

---

### **三、 数位DP**

#### **1. 什么是数位DP？我们什么时候会想到它？**

数位DP是一种专用于**计数**的DP技巧。
**识别信号**:
*   **超大区间计数**：要求你在一个巨大的整数区间 $[L, R]$ (比如 $R$ 到 $10^{18}$) 内，统计满足条件的数的个数。
*   **数位性质**：这种性质只和数的各位数字本身有关（例如，“不包含数字4”、“各位数字之和是偶数”），而与这个数的大小无直接关系。

#### **2. 核心思路：差分 + 逐位构造 (DFS)**
直接在 $[L, R]$ 上计数很困难，我们将其分解：
1.  **差分思想**：`count(L, R)` 的问题，转换为 `solve(R) - solve(L-1)` 的问题。`solve(x)` 表示在 $[0, x]$ 区间内满足条件的数的个数。
2.  **逐位构造**：`solve(x)` 的过程，就是去构造一个不多于 $x$ 的数，看有多少种合法的构造方法。我们用一个 `dfs` 函数，从高位到低位，一位一位地去填数字来统计方案数。`dfs(pos, state, limit, lead)` 是最核心的模板。
    *   `pos`: 当前正在填第几位。
    *   `state`: 一个或多个状态变量，记录了之前填的数字所形成的关键信息（比如前一位数字是什么）。
    *   `limit`: **最关键的参数**。它表示当前位可以填的数字是否受到上界 $x$ 的限制。如果前面填的数字和 $x$ 的高位都一模一样，那么当前位最大只能填到 $x$ 的对应位，`limit`为`true`；否则，当前位可以随便填 $0-9$，`limit`为`false`。
    *   `lead`: 一个布尔值，表示是否是前导零，因为有些规则对前导零有特殊处理。

#### **3. 经典入门例题：不要62**

**题目描述**
求区间 $[A, B]$ 内，不含数字 '4' 也不含连续的 '62' 的数的个数。

**输入格式**
多组测试数据，每行包含两个整数 $A$ 和 $B$。  
当 $A = B = 0$ 时，输入结束。

**输出格式**
对于每组测试数据，输出一个整数，表示满足条件的数的个数。

**数据范围**
- $0 \le A \le B \le 10^9$
- 输入不超过 $10^5$ 组测试数据

**样例输入**
```
1 100
0 0
```

**样例输出**
```
80
```

**样例解释**
在区间 $[1, 100]$ 内，不含数字 '4' 且不含连续的 '62' 的数共有 $80$ 个。

**C++ 代码实现**
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
long long dp[11][10]; // dp[pos][prev_digit]
std::vector<int> num;

// dfs返回在当前状态下，构造剩下位数的合法方案数
// 现在上限约束 0 ~ a[pos];
// 不超过 n 值
long long dfs(int pos, int prev, bool limit, bool lead) {
    // 成功构造到最后一位，说明找到一个合法数
    
    if (pos == num.size()) return 1; // 在不受限且非前导零的情况下使用记忆化
    if (!limit && !lead && dp[pos][prev] != -1) return dp[pos][prev];

    long long ans = 0;
    // 确定当前位能填的上限
    int up = limit ? num[pos] : 9; 

    for (int i = 0; i <= up; ++i) {
	    if (i == 4)
		    continue;
		if (i == 2 && prev == 6)
			continue;
        if (abs(i - prev) < 2)
	        continue;
		
        // 递归到下一位
        // limit: 只有当本来就受限且当前位也取到上限时，下一位才继续受限
        // lead: 只有当本来就是前导0且当前位也取0时，下一位才继续是前导0
        ans += dfs(pos + 1, i, limit && (i == up), lead && (i == 0));
    }

    if (!limit && !lead) {
        dp[pos][prev] = ans;
    }
    return ans;
}

long long calc(int x) {
    num.clear();
    string s = to_string(x);
    for (char c : s) num.push_back(c - '0');
	
    memset(dp, -1, sizeof(dp));
    // prev初始为-1或其他无效数字，因为第一位前面没有数字
    return dfs(0, -1, true, true);
}

int main() {
	long long a, b;
    while (std::cin >> a >> b && (a || b)) {
        std::cout << calc(b) - calc(a - 1) << std::endl;
    }
    return 0;
}
```

#### **4. 进阶练习：Windy数**

**题目描述**
不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。求区间 $[A, B]$ 内有多少个windy数。

**输入格式**
一行两个整数 $A$ 和 $B$，用空格分隔。

**输出格式**
一个整数，表示区间 $[A, B]$ 内windy数的个数。

**数据范围**
- $1 \le A \le B \le 2 \times 10^9$

**样例输入**
```
1 10
```

**样例输出**
```
9
```

**样例解释**
区间 $[1, 10]$ 内的windy数有：$1, 2, 3, 4, 5, 6, 7, 8, 9$。
数字 $10$ 不是windy数，因为相邻数字 $1$ 和 $0$ 的差为 $1 < 2$。

**解题思路**
与上一题的框架几乎完全一样，只是`dfs`中的判断逻辑不同。
*   `dfs(pos, prev, limit, lead)`:
    *   **剪枝**: 如果不是前导零 (`lead`为`false`)，且 `abs(i - prev) < 2`，则跳过。
    *   **注意**: `dfs` 中对前导零的处理要格外小心，因为 `prev` 对前导零无意义。当 `lead` 为 `true` 时，`prev` 的值应为一个特殊值，且不参与 `abs` 判断。