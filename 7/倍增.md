
### 一、从二分到倍增：寻找单调边界

我们之前都学过二分法。二分法通常用于在一个**单调**的序列或函数上，快速找到一个“分界点”。例如，在一单调递增序列中找到第一个大于等于 `x` 的数。
```cpp
while (l <= r)
{
	int mid = (l + r) / 2
	if (check(mid))
		l = mid + 1, ans = mid;
	else r = mid - 1;
}

int l, last = l;
for (int k = 20; k >= 0; --k)
{
	int nxt = last + (1 << k);
	if (check(nxt))
		last = nxt;
}

ans = last;


for (int j = 1; j <= 20; ++j)
	for (int i = 1; i <= n; ++i)
		nxt[i][j] = nxt[nxt[i][j - 1]][j - 1];

for (int k = 20; k >= 0; --k)
{
	int nxt = nxt[last][k];
	if (check(nxt))
		last = nxt;
}


for (int i = 1; i <= n; ++i)
	prod[i][0] = a[i] % mod;

nxt[i][j - 1] = (i + (1 << j - 1));

for (int j = 1; j <= 20; ++j)
	for (int i = 1; i <= n; ++i)
		prod[i][j] = 1ll * prod[i][j - 1] * prod[nxt[i][j - 1]][j - 1] % mod

while (q--)
{
	int l, r;
	cin >> l >> r;
	int ans = 1;
	int len = r - l + 1;

	for (int k = 20; k >= 0; --k)
	{
		int nxt = (l + (1 << k));
		if (nxt <= r)
		{
			ans = 1ll * ans * prod[l][k] % mod;
			l = nxt;
		}
	}
	cout << ans << endl;
}

```
现在我们来看一个类似的问题：假设你在一条无限长的数轴上的原点，每一步可以向前跳任意距离。给你 $N$ 次跳跃的机会，每次跳跃的距离都记录在数组 `d` 中。请问从原点出发，最多能跳多远？ 这是一个简单的问题，答案就是所有距离之和。

但如果问题加一个限制：找到一个最远的位置 `P`，使得从原点到达 `P` 的总步数**不超过** `K` 步。

这个问题就有了**单调性**：如果 `K` 步能到达 `P`，那么 `K+1` 步肯定也能到达 `P`。我们可以二分答案（二分最终的位置 `P`），但这不够高效。

让我们换个思路，直接“跳”。我们可以一步一步跳，直到跳了 `K` 步。但如果 `K` 很大，效率就很低。有没有像二分一样，每次能“跳过”大量决策的方法呢？

**倍增思想**登场了。它也利用了2的幂次方进行快速跳跃。

我们可以预处理出从某个位置开始，跳 $2^0, 2^1, 2^2, \dots$ 步分别能到达的位置。当我们要精确地跳 `K` 步时，就可以把 `K` 进行二进制拆分。例如，要跳13步（$13 = 8+4+1$），我们就可以从当前位置，先跳 $2^3=8$ 步，再跳 $2^2=4$ 步，最后跳 $2^0=1$ 步。

更进一步，在解决单调性问题时，倍增展现出与二分类似的“逼近”思想。假设我们要找一个满足条件的“最远”、“最高”、“最大”的位置。我们可以从大到小尝试每一种 $2^k$ 的步长：
1.  从当前位置 `pos`，尝试向上/向前跳 $2^{logN}$ 步。
2.  如果跳完之后的新位置 `new_pos` 仍然满足条件，说明目标点还在更远处，我们就跳过去（`pos = new_pos`）。
3.  如果跳完后不满足条件，说明这一步“跳得太远了”，我们就不跳。
4.  继续尝试更小的步长 $2^{logN-1}, 2^{logN-2}, \dots, 2^0$。

所有尝试结束后，当前位置就是我们能达到的、满足条件的“临界点”。这个从大到小尝试跳跃、能跳就跳的贪心过程，本质上是在用二进制位来“拼凑”出最终的答案，其思想和二分异曲同工，复杂度也都是对数级别的。

### 二、ST 表（Sparse Table）：区间查询的利器

ST表是倍增思想的直接应用，它解决的是**区间最值查询（Range Maximum/Minimum Query, RMQ）** 问题。这里利用的是倍增“成倍扩展”区间的思想，而不是“跳跃”。

```cpp
mx[x][p]

从 [x, x + (1 << p) - 1]

max(max(a, b), c) = max({a, b, c});

for (int i = 2; i <= n; ++i)
	log2[i] = log2[i >> 1] + 1;



for (int j = 1; j <= 20; ++j)
	for (int i = 1; i <= n; ++i)
		mx[i][j] = max(mx[i][j - 1] * mx[nxt[i][j - 1]][j - 1]);

while (q--)
{
	int l, r;
	cin >> l >> r;
	int ans = -1e9;
	int len = r - l + 1;
	
	int p = log2[len];
	
	ans = max(mx[l][p], mx[r - (1 << p) + 1][p]);
	
	cout << ans << endl;
}
```

#### 1. 知识点讲解

假设我们有一个长度为 $N$ 的静态数组 $A$，需要频繁查询某个区间 $[L, R]$ 内的最大值。

*   **核心思想**：我们预处理出所有以 `i` 为起点，长度为 $2^j$ 的区间的最大值。
*   **预处理**：我们用二维数组 `st[i][j]` 表示区间 $[i, i + 2^j - 1]$ 的最大值。
    *   **Base Case**: `st[i][0]` 就是 `A[i]` 本身 (长度为 $2^0=1$ 的区间)。
    *   **状态转移**: 长度为 $2^j$ 的区间 $[i, i+2^j-1]$ 可以被拆分成两个长度为 $2^{j-1}$ 的子区间：$[i, i+2^{j-1}-1]$ 和 $[i+2^{j-1}, i+2^j-1]$。
    *   转移方程为：$st[i][j] = \max(st[i][j-1], st[i + 2^{j-1}][j-1])$
    *   预处理复杂度为 $O(N \log N)$。
*   **查询**：查询区间 $[L, R]$。
    *   设区间长度为 $len = R - L + 1$。我们找到最大的 $k$ 使得 $2^k \le len$。
    *   我们将区间 $[L, R]$ 覆盖为两个长度为 $2^k$ 的、有重叠的区间：$[L, L+2^k-1]$ 和 $[R-2^k+1, R]$。
    *   由于求最大值时，元素重复计算不影响结果，所以整个区间的最大值就是 $\max(st[L][k], st[R - 2^k + 1][k])$。
    *   查询复杂度为 $O(1)$。

#### 2. 例题：静态区间最大值

**题目描述**
给定一个长度为 $N$ 的数列，和 $M$ 次查询，对于每次查询，输出区间 $[L, R]$ 内的最大值。

**数据范围**
*   $1 \le N \le 10^5$
*   $1 \le M \le 10^6$
*   $1 \le L \le R \le N$
*   数列中的元素大小在 `int` 范围内。

**样例输入**
```
8 3
1 5 2 6 3 8 4 7
1 5
3 8
2 6
```

**样例输出**
```
6
8
8
```

#### 3. C++ 参考代码

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

const int MAXN = 100005;
const int LOGN = 17; // log2(100005)约等于16.6，取17

int a[MAXN];
int st[MAXN][LOGN];
int log_table[MAXN];

// 预处理log2的值，避免重复计算
void precompute_log(int n) {
    log_table[1] = 0;
    for (int i = 2; i <= n; i++) {
        log_table[i] = log_table[i / 2] + 1;
    }
}

// 构建ST表
void build_st(int n) {
    for (int i = 1; i <= n; i++) {
        st[i][0] = a[i];
    }
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}

// 查询区间[L, R]的最大值
int query(int l, int r) {
    int k = log_table[r - l + 1];
    return max(st[l][k], st[r - (1 << k) + 1][k]);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    precompute_log(n);
    build_st(n);

    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        cout << query(l, r) << "\n";
    }

    return 0;
}
```

### 三、倍增法求最近公共祖先（LCA）

最近公共祖先（LCA）是树论中的一个基本问题。倍增法是解决LCA问题的最常用方法之一。这里完美体现了我们第一部分讲的“跳跃”和“逼近”思想。

#### 1. 知识点讲解

*   **预处理**：我们需要预处理两个信息：
    1.  `dep[i]`: 节点 `i` 的深度。
    2.  `fa[i][j]`: 节点 `i` 的第 $2^j$ 个祖先是谁。
*   这两个信息可以通过一次DFS完成。`dep` 容易计算。`fa[i][0]` 就是 `i` 的父节点，而 $fa[i][j] = fa[fa[i][j-1]][j-1]$ (i的第 $2^j$ 个祖先，是它第 $2^{j-1}$ 个祖先的第 $2^{j-1}$ 个祖先)。预处理复杂度 $O(N \log N)$。

*   **查询 `u` 和 `v` 的LCA**：
    1.  **拉平深度**：先让深度较深的点（假设是 `v`）向上跳，直到和 `u` 的深度相同。需要跳的步数是 `dep[v] - dep[u]`，我们用倍增思想（二进制拆分）来完成这次跳跃，复杂度 $O(\log N)$。
    2.  **同步逼近**：现在 `u` 和 `v` 深度相同。如果此时 `u == v`，那么LCA就是 `u`。否则，它们需要一起向上跳，直到它们的父节点相同。
        *   这里就用到了第一部分讲的单调性逼近思想。我们从大到小（`j` 从 `logN` 到 0）尝试让 `u` 和 `v` 同时跳 $2^j$ 步。
        *   如果它们跳到`fa[u][j]` 和 `fa[v][j]` 后，两个新节点**不相同**，说明LCA还在更上方，它们还没有相遇，这次跳跃是安全的。于是我们就更新 `u = fa[u][j]`，`v = fa[v][j]`。
        *   如果 `fa[u][j] == fa[v][j]`，说明这次跳跃“越过”了LCA或者正好到达LCA，为了找到LCA的 바로 아래 자식，我们不能跳这一步。
    3.  **确定LCA**：当所有 `j` 都尝试完毕，`u` 和 `v` 会停在LCA的正下方一层。因此，它们的父节点 `fa[u][0]` 就是LCA。整个查询复杂度 $O(\log N)$。

#### 2. 例题：最近公共祖先（LCA）

**题目描述**
给定一棵包含 $N$ 个节点的有根树，以及 $M$ 次查询。每次查询给出两个节点 $u$ 和 $v$，请求出它们的最近公共祖先。

**数据范围**
*   $1 \le N, M \le 10^5$
*   节点编号从 1 到 $N$。
*   根节点为 1。

```cpp

fa[root][0] = 0;

fa[u][0];

n = 10

fa[5][20] = 0

for (int j = 1; j <= 20; ++j)
	for (int i = 1; i <= n; ++i)
		fa[i][j] = fa[fa[i][j - 1]][j - 1];

auto dfs = [&](auto &&self, int u, int f) -> void
{
	L[i] = ++tot;
	id[tot] = i;
	for (auto [v, w] : edge[u])
		if (v != f)
			self(self, v, u);
	R[i] = tot;
};

把整个子树 + x

最后的 a 长什么样


for (int i = 1; i <= n; ++i)
	diff[i] = a[id[i]] - a[id[i - 1]];

u + x

diff[L[u]] += x;
diff[R[u] + 1] -= x;

for (int i = 1; i <= n; ++i)
	diff[i] += diff[i - 1];

a[i] = diff[L[i]];

int get_path_max(int u, int v)
{
	if (dep[u] < dep[v])
		swap(u, v);
	int step = dep[u] - dep[v];
	int ans = 0;
	for (int i = 0; i <= 20; ++i)
		if (1 << i & step)
		{
			u = fa[u][i];
			ans = max(ans, mx[u][i]);
		}
		
	for (int i = 20; i >= 0; --i)
		if (fa[u][i] != fa[v][i])
		{
			u = fa[u][i];
			v = fa[v][i];
			ans = max(ans, mx[u][i]);
			ans = max(ans, mx[v][i]);
		}
	// return max(ans, a[fa[u][0]]);
	return ans;
}


while (q--) // u -> v
{
	int u, v;
	cin >> u >> v;
	//
	++diff[L[u]];
	++diff[L[v]];
	diff[L[LCA(u, v)]] -= 2;
	// -----
	int lca = LCA(u, v);
	++diff[u];
	++diff[v];
	--diff[lca];
	--diff[fa[lca]];
}

for (int i = 1; i <= n; ++i)
	diff[i] += diff[i - 1];

cnt[i] = diff[id[i]];

auto dfs = [&](auto &&self, int u, int f, int from) -> void
{
	cnt[u] = diff[u];
	for (auto [v, w] : edge[u])
		if (v != f)
		{
			self(self, v, u, w);
			cnt[u] += cnt[v];
		}
	ans = max(ans, cnt[u] * from);
};

```

**样例输入**
```
5 3
1 2
1 3
2 4
2 5
4 5
3 4
2 3
```
**样例输出**
```
2
1
1
```

#### 3. C++ 参考代码

下面给出两种功能相同但代码结构略有不同的实现方式，以便加深理解。

**实现方法一：标准两步法**

这种写法将“拉平深度”和“同步跳跃”清晰地分为两个循环。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 100005;
const int LOGN = 17;

vector<int> adj[MAXN];
int fa[MAXN][LOGN];
int dep[MAXN];

// DFS预处理深度和fa[u][0]
void dfs(int u, int p) {
    dep[u] = dep[p] + 1;
    fa[u][0] = p;
    for (int v : adj[u]) {
        if (v != p) {
            dfs(v, u);
        }
    }
}

// 预处理所有fa[u][j]
void build_lca(int n) {
    for (int j = 1; j < LOGN; ++j) {
        for (int i = 1; i <= n; ++i) {
            // fa[i][j] = fa[ i的2^(j-1)祖先 ][j-1]
            if (fa[i][j - 1] != 0) {
                 fa[i][j] = fa[fa[i][j - 1]][j - 1];
            }
        }
    }
}

// 查询LCA
int lca(int u, int v) {
    // 1. 保证u的深度不小于v
    if (dep[u] < dep[v]) {
        swap(u, v);
    }

    // 2. 将u跳到和v同一深度
    for (int i = LOGN - 1; i >= 0; --i) {
        if (dep[u] - (1 << i) >= dep[v]) {
            u = fa[u][i];
        }
    }

    // 3. 如果v是u的祖先
    if (u == v) {
        return u;
    }

    // 4. u和v一起向上跳，直到LCA的子节点
    for (int i = LOGN - 1; i >= 0; --i) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }

    // 5. 返回它们的父节点
    return fa[u][0];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    cin >> n >> m;

    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // 假设根节点为1
    dfs(1, 0);
    build_lca(n);

    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u, v;
        cout << lca(u, v) << "\n";
    }

    return 0;
}
```

**实现方法二：封装跳跃函数**

这种写法将“向上跳k步”封装成一个独立的函数，代码更模块化。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 100005;
const int LOGN = 17;

vector<int> adj[MAXN];
int fa[MAXN][LOGN];
int dep[MAXN];

// DFS预处理
void dfs(int u, int p) {
    dep[u] = dep[p] + 1;
    fa[u][0] = p;
    for (int i = 1; i < LOGN; ++i) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v : adj[u]) {
        if (v != p) {
            dfs(v, u);
        }
    }
}

// 辅助函数：让节点u向上跳k步
int jump(int u, int k) {
    for (int i = 0; i < LOGN; ++i) {
        if ((k >> i) & 1) { // 如果k的二进制第i位是1，就跳2^i步
            u = fa[u][i];
        }
    }
    return u;
}

// 查询LCA
int lca_v2(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    
    // 1. 拉平深度
    u = jump(u, dep[u] - dep[v]);

    if (u == v) {
        return u;
    }

    // 2. 同步跳跃
    for (int i = LOGN - 1; i >= 0; --i) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    cin >> n >> m;

    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u, v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // 假设根节点为1
    dfs(1, 0);

    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u, v;
        cout << lca_v2(u, v) << "\n";
    }

    return 0;
}
```

### 总结

今天我们从二分的思想出发，理解了倍增的本质。倍增主要有两种应用模式：
1.  **处理单调性问题**：类似二分，通过从大到小尝试 $2^k$ 的步长，以贪心的方式快速“逼近”问题的解，如LCA中的同步跳跃过程。
2.  **分治与组合**：预处理出所有长度为 $2^k$ 的区间/路径信息，查询时将目标分解成对数个预处理好的信息块进行组合，如ST表和LCA中的“跳跃k步”。

倍增是一个非常优雅且高效的思想，希望大家能通过今天的学习，掌握这种思想，并在未来的练习中灵活运用。