好的，没有问题。这是一份根据您的要求，面向算法竞赛（C/C++）风格重写的，包含完整代码例题的讲义。


```cpp
if (n == 1)
	return false;
for (int i = 2; i * i <= n; ++i)
	if (n % i == 0)
		return false;
return true;




vector<pair<int, int>> factorize(int n) {
    vector<pair<int, int>> res;
    for (int i = 2; i * i <= n; i++) {
        if (n % i != 0) continue;
        int e = 0;
        while (n % i == 0) {
            e++;
            n /= i;
        }
        res.emplace_back(i, e);
    }
    if (n != 1) res.emplace_back(n, 1);
    return res;
}


int gcd(int a, int b)
{
	return b ? a : gcd(b, a % b);
}

ll lcm(ll a, ll b)
{
	return a / gcd(a, b) * b;
}

```
---

# 讲义：扩展欧几里得算法 (Extended Euclidean Algorithm)

## 一、 前置知识：裴蜀定理 (Bézout's Identity)

在进入算法本身之前，我们需要了解它所依据的数学定理——裴蜀定理。

#### **定理内容**

> 对于任意两个不全为零的整数 $a$ 和 $b$，必然存在一对整数 $x$ 和 $y$，使得等式成立：
>
> $ax + by = \text{gcd}(a, b)$
>
> 其中 $\text{gcd}(a, b)$ 是 $a$ 和 $b$ 的最大公约数。

#### **核心推论**

裴蜀定理最重要的推论，也是算法竞赛中最常用的结论是：

> 关于未知数 $x$ 和 $y$ 的线性丢番图方程 $ax + by = c$ 有整数解的**当且仅当** $c$ 是 $\text{gcd}(a, b)$ 的倍数。

这个推论是解决许多数论问题的基础。当我们看到形如 $ax+by=c$ 的方程时，第一反应就应该是检查 $\text{gcd}(a, b)$ 能否整除 $c$。

## 二、 扩展欧几里得算法 (exGCD)

标准的欧几里得算法（辗转相除法）可以求出 $\text{gcd}(a, b)$，而**扩展欧几里得算法 (Extended Euclidean Algorithm, exGCD)** 则可以在求出 $\text{gcd}(a, b)$ 的同时，找出满足裴蜀等式 $ax + by = \text{gcd}(a, b)$ 的一组特解 $(x, y)$。

#### **算法原理**

exGCD 的核心是递归。我们思考欧几里得算法的递归过程：$\text{gcd}(a, b) = \text{gcd}(b, a \pmod b)$。

**递归的终止条件：**
当 $b=0$ 时，$\text{gcd}(a, 0) = a$。此时的裴蜀等式为 $a \cdot x + 0 \cdot y = a$。显然，我们可以取一组特解 $x=1, y=0$。

**递归的回推过程：**
假设我们已经通过递归调用 `exgcd(b, a % b)` 得到了一组解 $(x', y')$，它满足：
$b \cdot x' + (a \pmod b) \cdot y' = \text{gcd}(b, a \pmod b)$

因为 $\text{gcd}(a, b) = \text{gcd}(b, a \pmod b)$，并且 $a \pmod b = a - \lfloor a/b \rfloor \cdot b$，我们可以将这个式子代入：
$b \cdot x' + (a - \lfloor a/b \rfloor \cdot b) \cdot y' = \text{gcd}(a, b)$

我们把这个式子展开，并重新以 $a$ 和 $b$ 为主元进行合并：
$b \cdot x' + a \cdot y' - \lfloor a/b \rfloor \cdot b \cdot y' = \text{gcd}(a, b)$
$a \cdot y' + b \cdot (x' - \lfloor a/b \rfloor \cdot y') = \text{gcd}(a, b)$

将这个结果与我们的目标式 $ax + by = \text{gcd}(a, b)$ 对比，可以发现：
*   $x = y'$
*   $y = x' - (a/b) \cdot y'$  (在 C++ 中 `a/b` 自动进行整除)

这就是从下一层递归的解 $(x', y')$ 推导出当前层解 $(x, y)$ 的方法。我们只需在递归的每一层应用这个关系，就能从基础解 $(1, 0)$ 一路回推出原问题的解。

#### **C++ 实现**

在算法竞赛中，通常使用一个函数 `exgcd(a, b, &x, &y)` 来实现，它返回 $a,b$ 的最大公约数，并将 $x, y$ 的解通过指针或引用传回。

```cpp
#include <iostream>

// 为了防止整数溢出，特别是在处理 c/d 时，通常使用 long long
using ll = long long;

/**
 * @brief 扩展欧几里得算法
 * @param a 
 * @param b 
 * @param x 返回的解x
 * @param y 返回的解y
 * @return ll 返回 a 和 b 的最大公约数
 */
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x); // 注意这里x和y的顺序，因为下一层的解是(y,x)
    y -= (a / b) * x;
    return d;
}
```

## 三、 算法应用

#### **1. 求解线性丢番图方程 $ax + by = c$**

这是 exGCD 最直接的应用。步骤如下：
1.  用 `exgcd(a, b, x, y)` 求出 $a,b$ 的最大公约数 $d$，并得到一组特解 $(x_0, y_0)$ 使得 $ax_0 + by_0 = d$。
2.  检查 $c \pmod d$ 是否为 0。如果不是，则原方程无整数解。
3.  如果是，则将等式 $ax_0 + by_0 = d$ 两边同时乘以 $k = c/d$。
    $a(x_0 \cdot k) + b(y_0 \cdot k) = d \cdot k = c$
    于是，原方程的一组特解为 $(x, y) = (x_0 \cdot (c/d), y_0 \cdot (c/d))$。

#### **2. 求解通解**

很多时候，题目会要求我们找一个满足特定条件的解（比如最小正整数解）。这就需要我们从一个特解推导出通解。
对于方程 $ax + by = c$，若已求得一组特解 $(x_p, y_p)$ 且 $\text{gcd}(a,b)=d$，其通解为：
$x = x_p + t \cdot \frac{b}{d}$
$y = y_p - t \cdot \frac{a}{d}$
其中 $t$ 为任意整数。

#### **3. 求解模逆元**

求解 $a$ 在模 $m$ 意义下的乘法逆元，就是求解一个整数 $x$ 满足：
$ax \equiv 1 \pmod m$
这个同余式等价于存在一个整数 $y$ 使得 $ax - 1 = my$，变形后即：
$ax + m(-y) = 1$
这正是可以用 exGCD 求解的线性丢番图方程。
使用 `exgcd(a, m, x, y)`，当且仅当返回的 $\text{gcd}(a, m)=1$ 时，方程有解。此时求出的 $x$ 就是一个解。但这个 $x$ 可能是负数，我们需要将它调整到 $[1, m-1]$ 范围内。一个常用的技巧是：`x = (x % m + m) % m;`。

---

## 四、 竞赛例题

现在，我们将以上知识应用到一个完整的算法竞赛题目中。

### **问题描述**

给定三个整数 $a, b, c$，请求解线性丢番图方程 $ax + by = c$，并找出其中 $x$ 的最小正整数解。

### **输入格式**

一行，包含三个整数 $a, b, c$。
($-10^9 \le a, b, c \le 10^9$, 保证 $a, b$ 不为0)

### **输出格式**

如果方程存在 $x$ 的正整数解，则输出 $x$ 的最小正整数值。
否则，输出 "No solution"。

### **样例输入**

```
87 31 2
```

### **样例输出**

```
10
```

### **题解分析**

这个题目是 exGCD 的经典应用，需要结合特解和通解的知识。

1.  **求解初始方程**
    我们要求解的是 $ax+by=c$。首先，我们通过 `exgcd(a, b, x, y)` 得到 $d = \text{gcd}(a,b)$ 和方程 $ax + by = d$ 的一组解 $(x_0, y_0)$。

2.  **判断可解性**
    根据裴蜀定理的推论，如果 $c$ 不是 $d$ 的倍数 (即 `c % d != 0`)，那么原方程 $ax+by=c$ 根本没有整数解。此时直接输出 "No solution"。

3.  **求特解**
    如果 `c % d == 0`，我们可以将 $ax_0 + by_0 = d$ 的两边同时乘以 $k = c/d$，得到 $a(x_0 k) + b(y_0 k) = c$。
    于是，原方程的一组特解为 $x_{part} = x_0 \cdot (c/d)$。

4.  **寻找最小正整数解**
    我们已经有了一个特解 $x_{part}$，现在需要利用通解公式找到最小的正整数解。
    $x$ 的通解形式为：
    $x = x_{part} + t \cdot \frac{b}{d}$
    其中 $t$ 为任意整数。为了方便，我们令 $b' = b/d$。则 $x = x_{part} + t \cdot b'$。

    我们需要找到一个整数 $t$ 使得 $x_{part} + t \cdot b' > 0$ 且值最小。
    这本质上是在一个以 $b'$ 为公差的等差数列中找到最小的正数。

    我们可以先将 $x_{part}$ 对 $b'$ 取模，使其落在一个方便处理的区间内。注意 $b'$ 可能为负数，为了统一处理，我们取其绝对值，即 $b' = \text{abs}(b/d)$。
    那么 $x$ 的所有解在模 $b'$ 意义下是同余的，都等于 $x_{part} \pmod {b'}$。
    
    让 $x_{part}$ 对 $b'$ 取正模，得到一个在 $[0, b'-1]$ 范围内的基准解：
    `x_min_non_neg = (x_part % b' + b') % b';`
    
    这个 `x_min_non_neg` 是所有解中最小的非负数解。
    *   如果 `x_min_non_neg` 是 `0`，那么最小的正整数解就是 $0 + b' = b'$。
    *   如果 `x_min_non_neg` 大于 `0`，那么它本身就是最小的正整数解。

    这两种情况可以合并为一个表达式： `(x_min_non_neg == 0) ? b' : x_min_non_neg`。

### **C++ 题解代码**

```cpp
#include <iostream>
#include <numeric> // For std::abs in C++17, though we can implement it manually

// 使用 long long 防止计算过程中溢出
using ll = long long;

/**
 * @brief 扩展欧几里得算法
 * @param a 
 * @param b 
 * @param x 返回的解x
 * @param y 返回的解y
 * @return ll 返回 a 和 b 的最大公约数
 */
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

// 手动实现一个abs，避免不必要的库依赖
ll custom_abs(ll n) {
    return n > 0 ? n : -n;
}

int main() {
    // 提高C++ IO效率
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    ll a, b, c;
    std::cin >> a >> b >> c;

    ll x, y;
    ll d = exgcd(a, b, x, y);

    // 步骤2: 判断可解性
    // 如果c不能被gcd(a,b)整除，则无整数解
    if (c % d != 0) {
        std::cout << "No solution" << std::endl;
        return 0;
    }

    // 步骤3: 计算特解
    // x,y现在是 ax+by=d 的解，我们需要 ax+by=c 的解
    // 两边同乘 c/d 即可
    // 为了防止溢出，先除后乘
    x = x * (c / d);
    
    // 步骤4: 寻找最小正整数解
    // x 的通解为 x_new = x + t * (b/d)
    // 我们需要找到最小的正整数解
    ll b_prime = b / d;
    
    // 我们要找的解都在模 abs(b_prime) 的同一个剩余类中
    // 找到这个剩余类中最小的非负数
    ll b_mod = custom_abs(b_prime);
    ll min_x = (x % b_mod + b_mod) % b_mod;

    // 如果最小非负解是0，那么最小正整数解应该是 0 + b_mod
    if (min_x == 0) {
        min_x = b_mod;
    }

    std::cout << min_x << std::endl;

    return 0;
}
```