好的，这里为您提供埃氏筛和欧拉筛的详细讲解，包括其基本原理、算法复杂度、代码模板以及欧拉筛的应用实例，并在必要之处加入了数学公式。

### 两种筛法的比较

| 特性 | 埃氏筛 (Sieve of Eratosthenes) | 欧拉筛 (Euler's Sieve) |
| --- | --- | --- |
| **核心思想** | 从2开始，将每个质数的倍数都标记为合数。 | 确保每个合数只被其最小的质因数筛掉一次。 |
| **时间复杂度** | $O(n \log \log n)$ | $O(n)$ |
| **空间复杂度** | $O(n)$ | $O(n)$ |
| **优点** | 实现简单，容易理解。 | 效率更高，是线性的，尤其在处理大规模数据时。 |
| **缺点** | 同一个合数可能被多次标记，存在冗余计算。 | 实现稍显复杂，需要理解其核心的线性性质。 |

---

### 埃氏筛 (Sieve of Eratosthenes)

埃氏筛是一种古老而简单的用于查找所有小于等于给定整数 $n$ 的质数的算法。

#### 1. 原理

其基本思想是：从2开始，当我们找到一个质数 $p$ 时，就把它的所有倍数 $2p, 3p, 4p, \dots$ 都标记为非质数（合数）。然后我们继续寻找下一个未被标记的数，这个数就是下一个质数，再重复上述过程，直到遍历完所有小于等于 $\sqrt{n}$ 的数。

为了优化，我们可以从一个质数 $p$ 的平方 $p^2$ 开始标记，因为所有小于 $p^2$ 的 $p$ 的倍数（如 $2p, 3p, \dots, (p-1)p$），必定有一个小于 $p$ 的质因数，所以在之前的步骤中已经被标记过了。

#### 2. 算法复杂度

*   **时间复杂度**: $O(n \log \log n)$。 这是因为对于每个质数 $p$，我们都标记了大约 $n/p$ 个数。所有质数的倒数之和 $\sum_{p \le n} \frac{1}{p}$ 近似于 $\log \log n$。
*   **空间复杂度**: $O(n)$，需要一个布尔数组来记录每个数是否为质数。

#### 3. C++ 代码模板

```cpp
#include <iostream>
#include <vector>
#include <cstring> // for memset

const int MAXN = 1000001;
bool is_prime[MAXN];
std::vector<int> primes;

// 筛选出 [1, n] 范围内的所有质数
void sieve_of_eratosthenes(int n) {
    // 初始化，假设所有数都是质数
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;

    for (int p = 2; p * p <= n; ++p) {
        if (is_prime[p]) {
            // 从 p*p 开始标记，因为小于 p*p 的 p 的倍数已被更小的质数筛过
            for (int i = p * p; i <= n; i += p) {
                is_prime[i] = false;
            }
        }
    }

    // 收集所有质数
    for (int p = 2; p <= n; ++p) {
        if (is_prime[p]) {
            primes.push_back(p);
        }
    }
}

int main() {
    int n = 100;
    sieve_of_eratosthenes(n);
    std::cout << "Primes up to " << n << " are: ";
    for (int prime : primes) {
        std::cout << prime << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

---

### 欧拉筛 (Euler's Sieve)

欧拉筛，也称为线性筛，是对埃氏筛的一种改进，其核心目标是确保每个合数只被其**最小的质因数**筛掉一次，从而达到线性的时间复杂度。

#### 1. 原理

欧拉筛同样从2开始遍历到 $n$。 对于当前遍历到的数 $i$：
1.  如果 $i$ 未被标记，则 $i$ 是一个质数，将其加入质数列表。
2.  遍历已找到的质数列表 `primes` 中的每个质数 $p$。
3.  标记 $i \cdot p$ 为合数。
4.  **关键步骤**: 如果 $i$ 能被当前的质数 $p$ 整除 (即 $i \pmod p = 0$)，则停止遍历质数列表。这是因为：
    *   此时 $p$ 是 $i$ 的最小质因数。
    *   那么 $p$ 也一定是 $i \cdot p$ 的最小质因数。我们在这里用 $p$ 筛掉 $i \cdot p$ 是正确的。
    *   对于任何大于 $p$ 的质数 $p'$, 合数 $i \cdot p'$ 的最小质因数也是 $p$，而不是 $p'$。因为 $i$ 是 $p$ 的倍数，可以写成 $i = k \cdot p$，那么 $i \cdot p' = (k \cdot p) \cdot p' = (k \cdot p') \cdot p$。这个数应该在后面遍历到 $k \cdot p'$ 时，被 $p$ 筛掉。为了保证“每个合数只被其最小质因数筛掉”的原则，我们必须在此处 `break`，防止它被更大的质数 $p'$ 筛掉。

#### 2. 算法复杂度

*   **时间复杂度**: $O(n)$。 每个合数都只被其最小的质因数筛了一次。
*   **空间复杂度**: $O(n)$，需要一个布尔数组和一个存储质数的数组。

#### 3. 应用例题：求区间内所有数的欧拉函数

**题目描述:** 给定一个正整数 $n$，求 1 到 $n$ 中每个数的欧拉函数。

**欧拉函数 $\phi(n)$**: 表示小于或等于 $n$ 的正整数中与 $n$ 互质的数的数目。

**解题思路:** 我们可以利用欧拉筛在筛选质数的同时，计算出每个数的欧拉函数值。

欧拉函数的计算性质：
1.  如果 $p$ 是质数, 那么 $\phi(p) = p - 1$。
2.  如果 $i \pmod p = 0$，其中 $p$ 是质数，那么 $p$ 是 $i$ 的一个质因子。此时，$i \cdot p$ 与 $i$ 包含相同的质因子，只是 $p$ 的指数更高。根据欧拉函数计算公式，可得 $\phi(i \cdot p) = \phi(i) \cdot p$。
3.  如果 $i \pmod p \neq 0$，其中 $p$ 是一个质数，那么 $p$ 不是 $i$ 的质因子，即 $i$ 与 $p$ 互质。根据欧拉函数的积性性质，$\phi(i \cdot p) = \phi(i) \cdot \phi(p) = \phi(i) \cdot (p - 1)$。

我们可以将这些性质完美地融入到欧拉筛的框架中。

**样例:**
*   **输入:** `n = 10`
*   **输出:**
    *   `phi[1] = 1`
    *   `phi[2] = 1`
    *   `phi[3] = 2`
    *   `phi[4] = 2`
    *   `phi[5] = 4`
    *   `phi[6] = 2`
    *   `phi[7] = 6`
    *   `phi[8] = 4`
    *   `phi[9] = 6`
    *   `phi[10] = 4`

**C++ 解题代码:**

```cpp
#include <iostream>
#include <vector>

const int MAXN = 1000001;
bool is_composite[MAXN]; // false表示是质数，true表示是合数
int primes[MAXN];        // 存储质数
int phi[MAXN];           // 存储欧拉函数值
int cnt = 0;             // 质数计数

// 使用欧拉筛计算 1 到 n 的欧拉函数
void euler_sieve_with_phi(int n) {
    phi[1] = 1; // 规定 phi[1] = 1
    for (int i = 2; i <= n; ++i) {
        if (!is_composite[i]) { // i 是质数
            primes[cnt++] = i;
            phi[i] = i - 1; // 性质1: phi(p) = p - 1
        }
        // 遍历已找到的质数来筛掉合数
        for (int j = 0; j < cnt && i * primes[j] <= n; ++j) {
            int p = primes[j];
            is_composite[i * p] = true;

            if (i % p == 0) { // p 是 i 的一个质因子
                phi[i * p] = phi[i] * p; // 性质2
                break; // 保证每个合数只被最小质因子筛掉
            } else { // p 不是 i 的质因子
                phi[i * p] = phi[i] * (p - 1); // 性质3
            }
        }
    }
}

int main() {
    int n;
    std::cout << "Enter a number n: ";
    std::cin >> n;

    euler_sieve_with_phi(n);

    for (int i = 1; i <= n; ++i) {
        std::cout << "phi(" << i << ") = " << phi[i] << std::endl;
    }

    return 0;
}
```

通过这个例子，我们可以看到欧拉筛强大的扩展性，它不仅能高效地找出质数，还能在相同的线性时间内计算出一些积性数论函数，例如欧拉函数。


```cpp
const int mod = 1e9 + 7;
int qpow(int x, int p)
{
	int res = 1;
	while (p)
	{
		if (p & 1)
			res = 1ll * res * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return res;
}

int exgcd(int a, int b, int &x, int &y)
{
	if (b == 0)
	{
		x = 1, y = 0;
		return a;
	}
	int res = exgcd(b, a % b, x, y);
	int x1 = y;
	int y1 = x - (a / b) * y;
	x = x1, y = y1;
	
	return res;
	
}

int get_inv(int a)
{
	int x = -1, y = -1;
	exgcd(a, mod, x, y);
	return x;
}

int fac[N], inv[N], inv_num[N];

// i!  i!^-1

int comb(int n, int m)
{
	if (m > n)
		return 0;
	return 1ll * fac[n] * inv[n - m] % mod * inv[m] % mod;
}

void init(int n)
{
	fac[0] = 1;
	for (int i = 1; i <= n; ++i)
		fac[i] = 1ll * fac[i - 1] * i % mod;
	inv[n] = get_inv(fac[n]);
	for (int i = n; i >= 1; --i)
		inv[i - 1] = 1ll * inv[i] * i % mod;

	for (int i = 1; i <= n; ++i)
		inv_num[i] = 1ll * inv[i] * fac[i - 1] % mod;
}


void swap(int &x, int &y)
{
	int t = x;
	x = y;
	y = t;
}


```